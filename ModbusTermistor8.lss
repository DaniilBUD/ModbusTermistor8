
AVRASM ver. 2.2.8  D:\Study\AVR_Projects\ModbusTermistorProject8\ModbusTermistor8\main.asm Tue May 23 01:13:17 2023

[builtin](2): Including file 'D:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.6.364\avrasm\inc\m8Adef.inc'
D:\Study\AVR_Projects\ModbusTermistorProject8\ModbusTermistor8\main.asm(1): Including file 'D:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.6.364\avrasm\inc\m8Adef.inc'
D:\Study\AVR_Projects\ModbusTermistorProject8\ModbusTermistor8\main.asm(17): warning: Use of undefined or forward referenced symbol 'AO_Data' in .equ/.set
D:\Study\AVR_Projects\ModbusTermistorProject8\ModbusTermistor8\main.asm(18): warning: Use of undefined or forward referenced symbol 'AO_Data' in .equ/.set
D:\Study\AVR_Projects\ModbusTermistorProject8\ModbusTermistor8\main.asm(19): warning: Use of undefined or forward referenced symbol 'AO_Data' in .equ/.set
D:\Study\AVR_Projects\ModbusTermistorProject8\ModbusTermistor8\main.asm(20): warning: Use of undefined or forward referenced symbol 'AI_Data' in .equ/.set
D:\Study\AVR_Projects\ModbusTermistorProject8\ModbusTermistor8\main.asm(21): warning: Use of undefined or forward referenced symbol 'AI_Data' in .equ/.set
[builtin](2): Including file 'D:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.6.364\avrasm\inc\m8Adef.inc'
D:\Study\AVR_Projects\ModbusTermistorProject8\ModbusTermistor8\main.asm(1): Including file 'D:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.6.364\avrasm\inc\m8Adef.inc'
                                 
                                 .include "m8Adef.inc" ;Подключение стандартной библиотеки для работы с Atmega8
                                 
                                 ;***** Created: 2011-02-09 12:03 ******* Source: ATmega8A.xml ************
                                 ;*************************************************************************
                                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                                 ;* 
                                 ;* Number            : AVR000
                                 ;* File Name         : "m8Adef.inc"
                                 ;* Title             : Register/Bit Definitions for the ATmega8A
                                 ;* Date              : 2011-02-09
                                 ;* Version           : 2.35
                                 ;* Support E-mail    : avr@atmel.com
                                 ;* Target MCU        : ATmega8A
                                 ;* 
                                 ;* DESCRIPTION
                                 ;* When including this file in the assembly program file, all I/O register 
                                 ;* names and I/O register bit names appearing in the data book can be used.
                                 ;* In addition, the six registers forming the three data pointers X, Y and 
                                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                                 ;* SRAM is also defined 
                                 ;* 
                                 ;* The Register names are represented by their hexadecimal address.
                                 ;* 
                                 ;* The Register Bit names are represented by their bit number (0-7).
                                 ;* 
                                 ;* Please observe the difference in using the bit names with instructions
                                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                                 ;* (skip if bit in register set/cleared). The following example illustrates
                                 ;* this:
                                 ;* 
                                 ;* in    r16,PORTB             ;read PORTB latch
                                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                                 ;* out   PORTB,r16             ;output to PORTB
                                 ;* 
                                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                                 ;* rjmp  TOV0_is_set           ;jump if set
                                 ;* ...                         ;otherwise do something else
                                 ;*************************************************************************
                                 
                                 #ifndef _M8ADEF_INC_
                                 #define _M8ADEF_INC_
                                 
                                 
                                 #pragma partinc 0
                                 
                                 ; ***** SPECIFY DEVICE ***************************************************
                                 .device ATmega8A
                                 #pragma AVRPART ADMIN PART_NAME ATmega8A
                                 .equ	SIGNATURE_000	= 0x1e
                                 .equ	SIGNATURE_001	= 0x93
                                 .equ	SIGNATURE_002	= 0x07
                                 
                                 #pragma AVRPART CORE CORE_VERSION V2E
                                 
                                 
                                 ; ***** I/O REGISTER DEFINITIONS *****************************************
                                 ; NOTE:
                                 ; Definitions marked "MEMORY MAPPED"are extended I/O ports
                                 ; and cannot be used with IN/OUT instructions
                                 .equ	SREG	= 0x3f
                                 .equ	SPL	= 0x3d
                                 .equ	SPH	= 0x3e
                                 .equ	GICR	= 0x3b
                                 .equ	GIFR	= 0x3a
                                 .equ	TIMSK	= 0x39
                                 .equ	TIFR	= 0x38
                                 .equ	SPMCR	= 0x37
                                 .equ	TWCR	= 0x36
                                 .equ	MCUCR	= 0x35
                                 .equ	MCUCSR	= 0x34
                                 .equ	TCCR0	= 0x33
                                 .equ	TCNT0	= 0x32
                                 .equ	OSCCAL	= 0x31
                                 .equ	SFIOR	= 0x30
                                 .equ	TCCR1A	= 0x2f
                                 .equ	TCCR1B	= 0x2e
                                 .equ	TCNT1L	= 0x2c
                                 .equ	TCNT1H	= 0x2d
                                 .equ	OCR1AL	= 0x2a
                                 .equ	OCR1AH	= 0x2b
                                 .equ	OCR1BL	= 0x28
                                 .equ	OCR1BH	= 0x29
                                 .equ	ICR1L	= 0x26
                                 .equ	ICR1H	= 0x27
                                 .equ	TCCR2	= 0x25
                                 .equ	TCNT2	= 0x24
                                 .equ	OCR2	= 0x23
                                 .equ	ASSR	= 0x22
                                 .equ	WDTCR	= 0x21
                                 .equ	UBRRH	= 0x20
                                 .equ	UCSRC	= 0x20
                                 .equ	EEARL	= 0x1e
                                 .equ	EEARH	= 0x1f
                                 .equ	EEDR	= 0x1d
                                 .equ	EECR	= 0x1c
                                 .equ	PORTB	= 0x18
                                 .equ	DDRB	= 0x17
                                 .equ	PINB	= 0x16
                                 .equ	PORTC	= 0x15
                                 .equ	DDRC	= 0x14
                                 .equ	PINC	= 0x13
                                 .equ	PORTD	= 0x12
                                 .equ	DDRD	= 0x11
                                 .equ	PIND	= 0x10
                                 .equ	SPDR	= 0x0f
                                 .equ	SPSR	= 0x0e
                                 .equ	SPCR	= 0x0d
                                 .equ	UDR	= 0x0c
                                 .equ	UCSRA	= 0x0b
                                 .equ	UCSRB	= 0x0a
                                 .equ	UBRRL	= 0x09
                                 .equ	ACSR	= 0x08
                                 .equ	ADMUX	= 0x07
                                 .equ	ADCSRA	= 0x06
                                 .equ	ADCL	= 0x04
                                 .equ	ADCH	= 0x05
                                 .equ	TWDR	= 0x03
                                 .equ	TWAR	= 0x02
                                 .equ	TWSR	= 0x01
                                 .equ	TWBR	= 0x00
                                 
                                 
                                 ; ***** BIT DEFINITIONS **************************************************
                                 
                                 ; ***** ANALOG_COMPARATOR ************
                                 ; SFIOR - Special Function IO Register
                                 .equ	ACME	= 3	; Analog Comparator Multiplexer Enable
                                 
                                 ; ACSR - Analog Comparator Control And Status Register
                                 .equ	ACIS0	= 0	; Analog Comparator Interrupt Mode Select bit 0
                                 .equ	ACIS1	= 1	; Analog Comparator Interrupt Mode Select bit 1
                                 .equ	ACIC	= 2	; Analog Comparator Input Capture Enable
                                 .equ	ACIE	= 3	; Analog Comparator Interrupt Enable
                                 .equ	ACI	= 4	; Analog Comparator Interrupt Flag
                                 .equ	ACO	= 5	; Analog Compare Output
                                 .equ	ACBG	= 6	; Analog Comparator Bandgap Select
                                 .equ	ACD	= 7	; Analog Comparator Disable
                                 
                                 
                                 ; ***** SPI **************************
                                 ; SPDR - SPI Data Register
                                 .equ	SPDR0	= 0	; SPI Data Register bit 0
                                 .equ	SPDR1	= 1	; SPI Data Register bit 1
                                 .equ	SPDR2	= 2	; SPI Data Register bit 2
                                 .equ	SPDR3	= 3	; SPI Data Register bit 3
                                 .equ	SPDR4	= 4	; SPI Data Register bit 4
                                 .equ	SPDR5	= 5	; SPI Data Register bit 5
                                 .equ	SPDR6	= 6	; SPI Data Register bit 6
                                 .equ	SPDR7	= 7	; SPI Data Register bit 7
                                 
                                 ; SPSR - SPI Status Register
                                 .equ	SPI2X	= 0	; Double SPI Speed Bit
                                 .equ	WCOL	= 6	; Write Collision Flag
                                 .equ	SPIF	= 7	; SPI Interrupt Flag
                                 
                                 ; SPCR - SPI Control Register
                                 .equ	SPR0	= 0	; SPI Clock Rate Select 0
                                 .equ	SPR1	= 1	; SPI Clock Rate Select 1
                                 .equ	CPHA	= 2	; Clock Phase
                                 .equ	CPOL	= 3	; Clock polarity
                                 .equ	MSTR	= 4	; Master/Slave Select
                                 .equ	DORD	= 5	; Data Order
                                 .equ	SPE	= 6	; SPI Enable
                                 .equ	SPIE	= 7	; SPI Interrupt Enable
                                 
                                 
                                 ; ***** EXTERNAL_INTERRUPT ***********
                                 ; GICR - General Interrupt Control Register
                                 .equ	GIMSK	= GICR	; For compatibility
                                 .equ	IVCE	= 0	; Interrupt Vector Change Enable
                                 .equ	IVSEL	= 1	; Interrupt Vector Select
                                 .equ	INT0	= 6	; External Interrupt Request 0 Enable
                                 .equ	INT1	= 7	; External Interrupt Request 1 Enable
                                 
                                 ; GIFR - General Interrupt Flag Register
                                 .equ	INTF0	= 6	; External Interrupt Flag 0
                                 .equ	INTF1	= 7	; External Interrupt Flag 1
                                 
                                 ; MCUCR - MCU Control Register
                                 .equ	ISC00	= 0	; Interrupt Sense Control 0 Bit 0
                                 .equ	ISC01	= 1	; Interrupt Sense Control 0 Bit 1
                                 .equ	ISC10	= 2	; Interrupt Sense Control 1 Bit 0
                                 .equ	ISC11	= 3	; Interrupt Sense Control 1 Bit 1
                                 
                                 
                                 ; ***** TIMER_COUNTER_0 **************
                                 ; TIMSK - Timer/Counter Interrupt Mask Register
                                 .equ	TOIE0	= 0	; Timer/Counter0 Overflow Interrupt Enable
                                 
                                 ; TIFR - Timer/Counter Interrupt Flag register
                                 .equ	TOV0	= 0	; Timer/Counter0 Overflow Flag
                                 
                                 ; TCCR0 - Timer/Counter0 Control Register
                                 .equ	CS00	= 0	; Clock Select0 bit 0
                                 .equ	CS01	= 1	; Clock Select0 bit 1
                                 .equ	CS02	= 2	; Clock Select0 bit 2
                                 
                                 ; TCNT0 - Timer Counter 0
                                 .equ	TCNT00	= 0	; Timer Counter 0 bit 0
                                 .equ	TCNT01	= 1	; Timer Counter 0 bit 1
                                 .equ	TCNT02	= 2	; Timer Counter 0 bit 2
                                 .equ	TCNT03	= 3	; Timer Counter 0 bit 3
                                 .equ	TCNT04	= 4	; Timer Counter 0 bit 4
                                 .equ	TCNT05	= 5	; Timer Counter 0 bit 5
                                 .equ	TCNT06	= 6	; Timer Counter 0 bit 6
                                 .equ	TCNT07	= 7	; Timer Counter 0 bit 7
                                 
                                 
                                 ; ***** TIMER_COUNTER_1 **************
                                 ; TIMSK - Timer/Counter Interrupt Mask Register
                                 .equ	TOIE1	= 2	; Timer/Counter1 Overflow Interrupt Enable
                                 .equ	OCIE1B	= 3	; Timer/Counter1 Output CompareB Match Interrupt Enable
                                 .equ	OCIE1A	= 4	; Timer/Counter1 Output CompareA Match Interrupt Enable
                                 .equ	TICIE1	= 5	; Timer/Counter1 Input Capture Interrupt Enable
                                 
                                 ; TIFR - Timer/Counter Interrupt Flag register
                                 .equ	TOV1	= 2	; Timer/Counter1 Overflow Flag
                                 .equ	OCF1B	= 3	; Output Compare Flag 1B
                                 .equ	OCF1A	= 4	; Output Compare Flag 1A
                                 .equ	ICF1	= 5	; Input Capture Flag 1
                                 
                                 ; TCCR1A - Timer/Counter1 Control Register A
                                 .equ	WGM10	= 0	; Waveform Generation Mode
                                 .equ	PWM10	= WGM10	; For compatibility
                                 .equ	WGM11	= 1	; Waveform Generation Mode
                                 .equ	PWM11	= WGM11	; For compatibility
                                 .equ	FOC1B	= 2	; Force Output Compare 1B
                                 .equ	FOC1A	= 3	; Force Output Compare 1A
                                 .equ	COM1B0	= 4	; Compare Output Mode 1B, bit 0
                                 .equ	COM1B1	= 5	; Compare Output Mode 1B, bit 1
                                 .equ	COM1A0	= 6	; Compare Ouput Mode 1A, bit 0
                                 .equ	COM1A1	= 7	; Compare Output Mode 1A, bit 1
                                 
                                 ; TCCR1B - Timer/Counter1 Control Register B
                                 .equ	CS10	= 0	; Prescaler source of Timer/Counter 1
                                 .equ	CS11	= 1	; Prescaler source of Timer/Counter 1
                                 .equ	CS12	= 2	; Prescaler source of Timer/Counter 1
                                 .equ	WGM12	= 3	; Waveform Generation Mode
                                 .equ	CTC10	= WGM12	; For compatibility
                                 .equ	CTC1	= WGM12	; For compatibility
                                 .equ	WGM13	= 4	; Waveform Generation Mode
                                 .equ	CTC11	= WGM13	; For compatibility
                                 .equ	ICES1	= 6	; Input Capture 1 Edge Select
                                 .equ	ICNC1	= 7	; Input Capture 1 Noise Canceler
                                 
                                 
                                 ; ***** TIMER_COUNTER_2 **************
                                 ; TIMSK - Timer/Counter Interrupt Mask register
                                 .equ	TOIE2	= 6	; Timer/Counter2 Overflow Interrupt Enable
                                 .equ	OCIE2	= 7	; Timer/Counter2 Output Compare Match Interrupt Enable
                                 
                                 ; TIFR - Timer/Counter Interrupt Flag Register
                                 .equ	TOV2	= 6	; Timer/Counter2 Overflow Flag
                                 .equ	OCF2	= 7	; Output Compare Flag 2
                                 
                                 ; TCCR2 - Timer/Counter2 Control Register
                                 .equ	CS20	= 0	; Clock Select bit 0
                                 .equ	CS21	= 1	; Clock Select bit 1
                                 .equ	CS22	= 2	; Clock Select bit 2
                                 .equ	WGM21	= 3	; Waveform Generation Mode
                                 .equ	CTC2	= WGM21	; For compatibility
                                 .equ	COM20	= 4	; Compare Output Mode bit 0
                                 .equ	COM21	= 5	; Compare Output Mode bit 1
                                 .equ	WGM20	= 6	; Waveform Genration Mode
                                 .equ	PWM2	= WGM20	; For compatibility
                                 .equ	FOC2	= 7	; Force Output Compare
                                 
                                 ; TCNT2 - Timer/Counter2
                                 .equ	TCNT2_0	= 0	; Timer/Counter 2 bit 0
                                 .equ	TCNT2_1	= 1	; Timer/Counter 2 bit 1
                                 .equ	TCNT2_2	= 2	; Timer/Counter 2 bit 2
                                 .equ	TCNT2_3	= 3	; Timer/Counter 2 bit 3
                                 .equ	TCNT2_4	= 4	; Timer/Counter 2 bit 4
                                 .equ	TCNT2_5	= 5	; Timer/Counter 2 bit 5
                                 .equ	TCNT2_6	= 6	; Timer/Counter 2 bit 6
                                 .equ	TCNT2_7	= 7	; Timer/Counter 2 bit 7
                                 
                                 ; OCR2 - Timer/Counter2 Output Compare Register
                                 .equ	OCR2_0	= 0	; Timer/Counter2 Output Compare Register Bit 0
                                 .equ	OCR2_1	= 1	; Timer/Counter2 Output Compare Register Bit 1
                                 .equ	OCR2_2	= 2	; Timer/Counter2 Output Compare Register Bit 2
                                 .equ	OCR2_3	= 3	; Timer/Counter2 Output Compare Register Bit 3
                                 .equ	OCR2_4	= 4	; Timer/Counter2 Output Compare Register Bit 4
                                 .equ	OCR2_5	= 5	; Timer/Counter2 Output Compare Register Bit 5
                                 .equ	OCR2_6	= 6	; Timer/Counter2 Output Compare Register Bit 6
                                 .equ	OCR2_7	= 7	; Timer/Counter2 Output Compare Register Bit 7
                                 
                                 ; ASSR - Asynchronous Status Register
                                 .equ	TCR2UB	= 0	; Timer/counter Control Register2 Update Busy
                                 .equ	OCR2UB	= 1	; Output Compare Register2 Update Busy
                                 .equ	TCN2UB	= 2	; Timer/Counter2 Update Busy
                                 .equ	AS2	= 3	; Asynchronous Timer/counter2
                                 
                                 ; SFIOR - Special Function IO Register
                                 .equ	PSR2	= 1	; Prescaler Reset Timer/Counter2
                                 
                                 
                                 ; ***** USART ************************
                                 ; UDR - USART I/O Data Register
                                 .equ	UDR0	= 0	; USART I/O Data Register bit 0
                                 .equ	UDR1	= 1	; USART I/O Data Register bit 1
                                 .equ	UDR2	= 2	; USART I/O Data Register bit 2
                                 .equ	UDR3	= 3	; USART I/O Data Register bit 3
                                 .equ	UDR4	= 4	; USART I/O Data Register bit 4
                                 .equ	UDR5	= 5	; USART I/O Data Register bit 5
                                 .equ	UDR6	= 6	; USART I/O Data Register bit 6
                                 .equ	UDR7	= 7	; USART I/O Data Register bit 7
                                 
                                 ; UCSRA - USART Control and Status Register A
                                 .equ	USR	= UCSRA	; For compatibility
                                 .equ	MPCM	= 0	; Multi-processor Communication Mode
                                 .equ	U2X	= 1	; Double the USART transmission speed
                                 .equ	UPE	= 2	; Parity Error
                                 .equ	PE	= UPE	; For compatibility
                                 .equ	DOR	= 3	; Data overRun
                                 .equ	FE	= 4	; Framing Error
                                 .equ	UDRE	= 5	; USART Data Register Empty
                                 .equ	TXC	= 6	; USART Transmitt Complete
                                 .equ	RXC	= 7	; USART Receive Complete
                                 
                                 ; UCSRB - USART Control and Status Register B
                                 .equ	UCR	= UCSRB	; For compatibility
                                 .equ	TXB8	= 0	; Transmit Data Bit 8
                                 .equ	RXB8	= 1	; Receive Data Bit 8
                                 .equ	UCSZ2	= 2	; Character Size
                                 .equ	CHR9	= UCSZ2	; For compatibility
                                 .equ	TXEN	= 3	; Transmitter Enable
                                 .equ	RXEN	= 4	; Receiver Enable
                                 .equ	UDRIE	= 5	; USART Data register Empty Interrupt Enable
                                 .equ	TXCIE	= 6	; TX Complete Interrupt Enable
                                 .equ	RXCIE	= 7	; RX Complete Interrupt Enable
                                 
                                 ; UCSRC - USART Control and Status Register C
                                 .equ	UCPOL	= 0	; Clock Polarity
                                 .equ	UCSZ0	= 1	; Character Size
                                 .equ	UCSZ1	= 2	; Character Size
                                 .equ	USBS	= 3	; Stop Bit Select
                                 .equ	UPM0	= 4	; Parity Mode Bit 0
                                 .equ	UPM1	= 5	; Parity Mode Bit 1
                                 .equ	UMSEL	= 6	; USART Mode Select
                                 .equ	URSEL	= 7	; Register Select
                                 
                                 .equ	UBRRHI	= UBRRH	; For compatibility
                                 
                                 ; ***** TWI **************************
                                 ; TWBR - TWI Bit Rate register
                                 .equ	I2BR	= TWBR	; For compatibility
                                 .equ	TWBR0	= 0	; 
                                 .equ	TWBR1	= 1	; 
                                 .equ	TWBR2	= 2	; 
                                 .equ	TWBR3	= 3	; 
                                 .equ	TWBR4	= 4	; 
                                 .equ	TWBR5	= 5	; 
                                 .equ	TWBR6	= 6	; 
                                 .equ	TWBR7	= 7	; 
                                 
                                 ; TWCR - TWI Control Register
                                 .equ	I2CR	= TWCR	; For compatibility
                                 .equ	TWIE	= 0	; TWI Interrupt Enable
                                 .equ	I2IE	= TWIE	; For compatibility
                                 .equ	TWEN	= 2	; TWI Enable Bit
                                 .equ	I2EN	= TWEN	; For compatibility
                                 .equ	ENI2C	= TWEN	; For compatibility
                                 .equ	TWWC	= 3	; TWI Write Collition Flag
                                 .equ	I2WC	= TWWC	; For compatibility
                                 .equ	TWSTO	= 4	; TWI Stop Condition Bit
                                 .equ	I2STO	= TWSTO	; For compatibility
                                 .equ	TWSTA	= 5	; TWI Start Condition Bit
                                 .equ	I2STA	= TWSTA	; For compatibility
                                 .equ	TWEA	= 6	; TWI Enable Acknowledge Bit
                                 .equ	I2EA	= TWEA	; For compatibility
                                 .equ	TWINT	= 7	; TWI Interrupt Flag
                                 .equ	I2INT	= TWINT	; For compatibility
                                 
                                 ; TWSR - TWI Status Register
                                 .equ	I2SR	= TWSR	; For compatibility
                                 .equ	TWPS0	= 0	; TWI Prescaler
                                 .equ	TWS0	= TWPS0	; For compatibility
                                 .equ	I2GCE	= TWPS0	; For compatibility
                                 .equ	TWPS1	= 1	; TWI Prescaler
                                 .equ	TWS1	= TWPS1	; For compatibility
                                 .equ	TWS3	= 3	; TWI Status
                                 .equ	I2S3	= TWS3	; For compatibility
                                 .equ	TWS4	= 4	; TWI Status
                                 .equ	I2S4	= TWS4	; For compatibility
                                 .equ	TWS5	= 5	; TWI Status
                                 .equ	I2S5	= TWS5	; For compatibility
                                 .equ	TWS6	= 6	; TWI Status
                                 .equ	I2S6	= TWS6	; For compatibility
                                 .equ	TWS7	= 7	; TWI Status
                                 .equ	I2S7	= TWS7	; For compatibility
                                 
                                 ; TWDR - TWI Data register
                                 .equ	I2DR	= TWDR	; For compatibility
                                 .equ	TWD0	= 0	; TWI Data Register Bit 0
                                 .equ	TWD1	= 1	; TWI Data Register Bit 1
                                 .equ	TWD2	= 2	; TWI Data Register Bit 2
                                 .equ	TWD3	= 3	; TWI Data Register Bit 3
                                 .equ	TWD4	= 4	; TWI Data Register Bit 4
                                 .equ	TWD5	= 5	; TWI Data Register Bit 5
                                 .equ	TWD6	= 6	; TWI Data Register Bit 6
                                 .equ	TWD7	= 7	; TWI Data Register Bit 7
                                 
                                 ; TWAR - TWI (Slave) Address register
                                 .equ	I2AR	= TWAR	; For compatibility
                                 .equ	TWGCE	= 0	; TWI General Call Recognition Enable Bit
                                 .equ	TWA0	= 1	; TWI (Slave) Address register Bit 0
                                 .equ	TWA1	= 2	; TWI (Slave) Address register Bit 1
                                 .equ	TWA2	= 3	; TWI (Slave) Address register Bit 2
                                 .equ	TWA3	= 4	; TWI (Slave) Address register Bit 3
                                 .equ	TWA4	= 5	; TWI (Slave) Address register Bit 4
                                 .equ	TWA5	= 6	; TWI (Slave) Address register Bit 5
                                 .equ	TWA6	= 7	; TWI (Slave) Address register Bit 6
                                 
                                 
                                 ; ***** WATCHDOG *********************
                                 ; WDTCR - Watchdog Timer Control Register
                                 .equ	WDTCSR	= WDTCR	; For compatibility
                                 .equ	WDP0	= 0	; Watch Dog Timer Prescaler bit 0
                                 .equ	WDP1	= 1	; Watch Dog Timer Prescaler bit 1
                                 .equ	WDP2	= 2	; Watch Dog Timer Prescaler bit 2
                                 .equ	WDE	= 3	; Watch Dog Enable
                                 .equ	WDCE	= 4	; Watchdog Change Enable
                                 .equ	WDTOE	= WDCE	; For compatibility
                                 
                                 
                                 ; ***** PORTB ************************
                                 ; PORTB - Port B Data Register
                                 .equ	PORTB0	= 0	; Port B Data Register bit 0
                                 .equ	PB0	= 0	; For compatibility
                                 .equ	PORTB1	= 1	; Port B Data Register bit 1
                                 .equ	PB1	= 1	; For compatibility
                                 .equ	PORTB2	= 2	; Port B Data Register bit 2
                                 .equ	PB2	= 2	; For compatibility
                                 .equ	PORTB3	= 3	; Port B Data Register bit 3
                                 .equ	PB3	= 3	; For compatibility
                                 .equ	PORTB4	= 4	; Port B Data Register bit 4
                                 .equ	PB4	= 4	; For compatibility
                                 .equ	PORTB5	= 5	; Port B Data Register bit 5
                                 .equ	PB5	= 5	; For compatibility
                                 .equ	PORTB6	= 6	; Port B Data Register bit 6
                                 .equ	PB6	= 6	; For compatibility
                                 .equ	PORTB7	= 7	; Port B Data Register bit 7
                                 .equ	PB7	= 7	; For compatibility
                                 
                                 ; DDRB - Port B Data Direction Register
                                 .equ	DDB0	= 0	; Port B Data Direction Register bit 0
                                 .equ	DDB1	= 1	; Port B Data Direction Register bit 1
                                 .equ	DDB2	= 2	; Port B Data Direction Register bit 2
                                 .equ	DDB3	= 3	; Port B Data Direction Register bit 3
                                 .equ	DDB4	= 4	; Port B Data Direction Register bit 4
                                 .equ	DDB5	= 5	; Port B Data Direction Register bit 5
                                 .equ	DDB6	= 6	; Port B Data Direction Register bit 6
                                 .equ	DDB7	= 7	; Port B Data Direction Register bit 7
                                 
                                 ; PINB - Port B Input Pins
                                 .equ	PINB0	= 0	; Port B Input Pins bit 0
                                 .equ	PINB1	= 1	; Port B Input Pins bit 1
                                 .equ	PINB2	= 2	; Port B Input Pins bit 2
                                 .equ	PINB3	= 3	; Port B Input Pins bit 3
                                 .equ	PINB4	= 4	; Port B Input Pins bit 4
                                 .equ	PINB5	= 5	; Port B Input Pins bit 5
                                 .equ	PINB6	= 6	; Port B Input Pins bit 6
                                 .equ	PINB7	= 7	; Port B Input Pins bit 7
                                 
                                 
                                 ; ***** PORTC ************************
                                 ; PORTC - Port C Data Register
                                 .equ	PORTC0	= 0	; Port C Data Register bit 0
                                 .equ	PC0	= 0	; For compatibility
                                 .equ	PORTC1	= 1	; Port C Data Register bit 1
                                 .equ	PC1	= 1	; For compatibility
                                 .equ	PORTC2	= 2	; Port C Data Register bit 2
                                 .equ	PC2	= 2	; For compatibility
                                 .equ	PORTC3	= 3	; Port C Data Register bit 3
                                 .equ	PC3	= 3	; For compatibility
                                 .equ	PORTC4	= 4	; Port C Data Register bit 4
                                 .equ	PC4	= 4	; For compatibility
                                 .equ	PORTC5	= 5	; Port C Data Register bit 5
                                 .equ	PC5	= 5	; For compatibility
                                 .equ	PORTC6	= 6	; Port C Data Register bit 6
                                 .equ	PC6	= 6	; For compatibility
                                 
                                 ; DDRC - Port C Data Direction Register
                                 .equ	DDC0	= 0	; Port C Data Direction Register bit 0
                                 .equ	DDC1	= 1	; Port C Data Direction Register bit 1
                                 .equ	DDC2	= 2	; Port C Data Direction Register bit 2
                                 .equ	DDC3	= 3	; Port C Data Direction Register bit 3
                                 .equ	DDC4	= 4	; Port C Data Direction Register bit 4
                                 .equ	DDC5	= 5	; Port C Data Direction Register bit 5
                                 .equ	DDC6	= 6	; Port C Data Direction Register bit 6
                                 
                                 ; PINC - Port C Input Pins
                                 .equ	PINC0	= 0	; Port C Input Pins bit 0
                                 .equ	PINC1	= 1	; Port C Input Pins bit 1
                                 .equ	PINC2	= 2	; Port C Input Pins bit 2
                                 .equ	PINC3	= 3	; Port C Input Pins bit 3
                                 .equ	PINC4	= 4	; Port C Input Pins bit 4
                                 .equ	PINC5	= 5	; Port C Input Pins bit 5
                                 .equ	PINC6	= 6	; Port C Input Pins bit 6
                                 
                                 
                                 ; ***** PORTD ************************
                                 ; PORTD - Port D Data Register
                                 .equ	PORTD0	= 0	; Port D Data Register bit 0
                                 .equ	PD0	= 0	; For compatibility
                                 .equ	PORTD1	= 1	; Port D Data Register bit 1
                                 .equ	PD1	= 1	; For compatibility
                                 .equ	PORTD2	= 2	; Port D Data Register bit 2
                                 .equ	PD2	= 2	; For compatibility
                                 .equ	PORTD3	= 3	; Port D Data Register bit 3
                                 .equ	PD3	= 3	; For compatibility
                                 .equ	PORTD4	= 4	; Port D Data Register bit 4
                                 .equ	PD4	= 4	; For compatibility
                                 .equ	PORTD5	= 5	; Port D Data Register bit 5
                                 .equ	PD5	= 5	; For compatibility
                                 .equ	PORTD6	= 6	; Port D Data Register bit 6
                                 .equ	PD6	= 6	; For compatibility
                                 .equ	PORTD7	= 7	; Port D Data Register bit 7
                                 .equ	PD7	= 7	; For compatibility
                                 
                                 ; DDRD - Port D Data Direction Register
                                 .equ	DDD0	= 0	; Port D Data Direction Register bit 0
                                 .equ	DDD1	= 1	; Port D Data Direction Register bit 1
                                 .equ	DDD2	= 2	; Port D Data Direction Register bit 2
                                 .equ	DDD3	= 3	; Port D Data Direction Register bit 3
                                 .equ	DDD4	= 4	; Port D Data Direction Register bit 4
                                 .equ	DDD5	= 5	; Port D Data Direction Register bit 5
                                 .equ	DDD6	= 6	; Port D Data Direction Register bit 6
                                 .equ	DDD7	= 7	; Port D Data Direction Register bit 7
                                 
                                 ; PIND - Port D Input Pins
                                 .equ	PIND0	= 0	; Port D Input Pins bit 0
                                 .equ	PIND1	= 1	; Port D Input Pins bit 1
                                 .equ	PIND2	= 2	; Port D Input Pins bit 2
                                 .equ	PIND3	= 3	; Port D Input Pins bit 3
                                 .equ	PIND4	= 4	; Port D Input Pins bit 4
                                 .equ	PIND5	= 5	; Port D Input Pins bit 5
                                 .equ	PIND6	= 6	; Port D Input Pins bit 6
                                 .equ	PIND7	= 7	; Port D Input Pins bit 7
                                 
                                 
                                 ; ***** EEPROM ***********************
                                 ; EEDR - EEPROM Data Register
                                 .equ	EEDR0	= 0	; EEPROM Data Register bit 0
                                 .equ	EEDR1	= 1	; EEPROM Data Register bit 1
                                 .equ	EEDR2	= 2	; EEPROM Data Register bit 2
                                 .equ	EEDR3	= 3	; EEPROM Data Register bit 3
                                 .equ	EEDR4	= 4	; EEPROM Data Register bit 4
                                 .equ	EEDR5	= 5	; EEPROM Data Register bit 5
                                 .equ	EEDR6	= 6	; EEPROM Data Register bit 6
                                 .equ	EEDR7	= 7	; EEPROM Data Register bit 7
                                 
                                 ; EECR - EEPROM Control Register
                                 .equ	EERE	= 0	; EEPROM Read Enable
                                 .equ	EEWE	= 1	; EEPROM Write Enable
                                 .equ	EEMWE	= 2	; EEPROM Master Write Enable
                                 .equ	EEWEE	= EEMWE	; For compatibility
                                 .equ	EERIE	= 3	; EEPROM Ready Interrupt Enable
                                 
                                 
                                 ; ***** CPU **************************
                                 ; SREG - Status Register
                                 .equ	SREG_C	= 0	; Carry Flag
                                 .equ	SREG_Z	= 1	; Zero Flag
                                 .equ	SREG_N	= 2	; Negative Flag
                                 .equ	SREG_V	= 3	; Two's Complement Overflow Flag
                                 .equ	SREG_S	= 4	; Sign Bit
                                 .equ	SREG_H	= 5	; Half Carry Flag
                                 .equ	SREG_T	= 6	; Bit Copy Storage
                                 .equ	SREG_I	= 7	; Global Interrupt Enable
                                 
                                 ; MCUCR - MCU Control Register
                                 ;.equ	ISC00	= 0	; Interrupt Sense Control 0 Bit 0
                                 ;.equ	ISC01	= 1	; Interrupt Sense Control 0 Bit 1
                                 ;.equ	ISC10	= 2	; Interrupt Sense Control 1 Bit 0
                                 ;.equ	ISC11	= 3	; Interrupt Sense Control 1 Bit 1
                                 .equ	SM0	= 4	; Sleep Mode Select
                                 .equ	SM1	= 5	; Sleep Mode Select
                                 .equ	SM2	= 6	; Sleep Mode Select
                                 .equ	SE	= 7	; Sleep Enable
                                 
                                 ; MCUCSR - MCU Control And Status Register
                                 .equ	MCUSR	= MCUCSR	; For compatibility
                                 .equ	PORF	= 0	; Power-on reset flag
                                 .equ	EXTRF	= 1	; External Reset Flag
                                 .equ	BORF	= 2	; Brown-out Reset Flag
                                 .equ	WDRF	= 3	; Watchdog Reset Flag
                                 
                                 ; OSCCAL - Oscillator Calibration Value
                                 .equ	CAL0	= 0	; Oscillator Calibration Value Bit0
                                 .equ	CAL1	= 1	; Oscillator Calibration Value Bit1
                                 .equ	CAL2	= 2	; Oscillator Calibration Value Bit2
                                 .equ	CAL3	= 3	; Oscillator Calibration Value Bit3
                                 .equ	CAL4	= 4	; Oscillator Calibration Value Bit4
                                 .equ	CAL5	= 5	; Oscillator Calibration Value Bit5
                                 .equ	CAL6	= 6	; Oscillator Calibration Value Bit6
                                 .equ	CAL7	= 7	; Oscillator Calibration Value Bit7
                                 
                                 ; SPMCR - Store Program Memory Control Register
                                 .equ	SPMEN	= 0	; Store Program Memory Enable
                                 .equ	PGERS	= 1	; Page Erase
                                 .equ	PGWRT	= 2	; Page Write
                                 .equ	BLBSET	= 3	; Boot Lock Bit Set
                                 .equ	RWWSRE	= 4	; Read-While-Write Section Read Enable
                                 .equ	RWWSB	= 6	; Read-While-Write Section Busy
                                 .equ	SPMIE	= 7	; SPM Interrupt Enable
                                 
                                 ; SFIOR - Special Function IO Register
                                 .equ	PSR10	= 0	; Prescaler Reset Timer/Counter1 and Timer/Counter0
                                 .equ	PUD	= 2	; Pull-up Disable
                                 .equ	ADHSM	= 4	; ADC High Speed Mode
                                 
                                 
                                 ; ***** AD_CONVERTER *****************
                                 ; ADMUX - The ADC multiplexer Selection Register
                                 .equ	MUX0	= 0	; Analog Channel and Gain Selection Bits
                                 .equ	MUX1	= 1	; Analog Channel and Gain Selection Bits
                                 .equ	MUX2	= 2	; Analog Channel and Gain Selection Bits
                                 .equ	MUX3	= 3	; Analog Channel and Gain Selection Bits
                                 .equ	ADLAR	= 5	; Left Adjust Result
                                 .equ	REFS0	= 6	; Reference Selection Bit 0
                                 .equ	REFS1	= 7	; Reference Selection Bit 1
                                 
                                 ; ADCSRA - The ADC Control and Status register
                                 .equ	ADCSR	= ADCSRA	; For compatibility
                                 .equ	ADPS0	= 0	; ADC  Prescaler Select Bits
                                 .equ	ADPS1	= 1	; ADC  Prescaler Select Bits
                                 .equ	ADPS2	= 2	; ADC  Prescaler Select Bits
                                 .equ	ADIE	= 3	; ADC Interrupt Enable
                                 .equ	ADIF	= 4	; ADC Interrupt Flag
                                 .equ	ADFR	= 5	; ADC  Free Running Select
                                 .equ	ADSC	= 6	; ADC Start Conversion
                                 .equ	ADEN	= 7	; ADC Enable
                                 
                                 
                                 
                                 ; ***** LOCKSBITS ********************************************************
                                 .equ	LB1	= 0	; Lock bit
                                 .equ	LB2	= 1	; Lock bit
                                 .equ	BLB01	= 2	; Boot Lock bit
                                 .equ	BLB02	= 3	; Boot Lock bit
                                 .equ	BLB11	= 4	; Boot lock bit
                                 .equ	BLB12	= 5	; Boot lock bit
                                 
                                 
                                 ; ***** FUSES ************************************************************
                                 ; LOW fuse bits
                                 .equ	CKSEL0	= 0	; Select Clock Source
                                 .equ	CKSEL1	= 1	; Select Clock Source
                                 .equ	CKSEL2	= 2	; Select Clock Source
                                 .equ	CKSEL3	= 3	; Select Clock Source
                                 .equ	SUT0	= 4	; Select start-up time
                                 .equ	SUT1	= 5	; Select start-up time
                                 .equ	BODEN	= 6	; Brown out detector enable
                                 .equ	BODLEVEL	= 7	; Brown out detector trigger level
                                 
                                 ; HIGH fuse bits
                                 .equ	BOOTRST	= 0	; Select Reset Vector
                                 .equ	BOOTSZ0	= 1	; Select Boot Size
                                 .equ	BOOTSZ1	= 2	; Select Boot Size
                                 .equ	EESAVE	= 3	; EEPROM memory is preserved through chip erase
                                 .equ	CKOPT	= 4	; Oscillator Options
                                 .equ	SPIEN	= 5	; Enable Serial programming and Data Downloading
                                 .equ	WTDON	= 6	; Enable watchdog
                                 .equ	RSTDISBL	= 7	; Disable reset
                                 
                                 
                                 
                                 ; ***** CPU REGISTER DEFINITIONS *****************************************
                                 .def	XH	= r27
                                 .def	XL	= r26
                                 .def	YH	= r29
                                 .def	YL	= r28
                                 .def	ZH	= r31
                                 .def	ZL	= r30
                                 
                                 
                                 
                                 ; ***** DATA MEMORY DECLARATIONS *****************************************
                                 .equ	FLASHEND	= 0x0fff	; Note: Word address
                                 .equ	IOEND	= 0x003f
                                 .equ	SRAM_START	= 0x0060
                                 .equ	SRAM_SIZE	= 1024
                                 .equ	RAMEND	= 0x045f
                                 .equ	XRAMEND	= 0x0000
                                 .equ	E2END	= 0x01ff
                                 .equ	EEPROMEND	= 0x01ff
                                 .equ	EEADRBITS	= 9
                                 #pragma AVRPART MEMORY PROG_FLASH 8192
                                 #pragma AVRPART MEMORY EEPROM 512
                                 #pragma AVRPART MEMORY INT_SRAM SIZE 1024
                                 #pragma AVRPART MEMORY INT_SRAM START_ADDR 0x60
                                 
                                 
                                 
                                 ; ***** BOOTLOADER DECLARATIONS ******************************************
                                 .equ	NRWW_START_ADDR	= 0xc00
                                 .equ	NRWW_STOP_ADDR	= 0xfff
                                 .equ	RWW_START_ADDR	= 0x0
                                 .equ	RWW_STOP_ADDR	= 0xbff
                                 .equ	PAGESIZE	= 32
                                 .equ	FIRSTBOOTSTART	= 0xf80
                                 .equ	SECONDBOOTSTART	= 0xf00
                                 .equ	THIRDBOOTSTART	= 0xe00
                                 .equ	FOURTHBOOTSTART	= 0xc00
                                 .equ	SMALLBOOTSTART	= FIRSTBOOTSTART
                                 .equ	LARGEBOOTSTART	= FOURTHBOOTSTART
                                 
                                 
                                 
                                 ; ***** INTERRUPT VECTORS ************************************************
                                 .equ	INT0addr	= 0x0001	; External Interrupt Request 0
                                 .equ	INT1addr	= 0x0002	; External Interrupt Request 1
                                 .equ	OC2addr	= 0x0003	; Timer/Counter2 Compare Match
                                 .equ	OVF2addr	= 0x0004	; Timer/Counter2 Overflow
                                 .equ	ICP1addr	= 0x0005	; Timer/Counter1 Capture Event
                                 .equ	OC1Aaddr	= 0x0006	; Timer/Counter1 Compare Match A
                                 .equ	OC1Baddr	= 0x0007	; Timer/Counter1 Compare Match B
                                 .equ	OVF1addr	= 0x0008	; Timer/Counter1 Overflow
                                 .equ	OVF0addr	= 0x0009	; Timer/Counter0 Overflow
                                 .equ	SPIaddr	= 0x000a	; Serial Transfer Complete
                                 .equ	URXCaddr	= 0x000b	; USART, Rx Complete
                                 .equ	UDREaddr	= 0x000c	; USART Data Register Empty
                                 .equ	UTXCaddr	= 0x000d	; USART, Tx Complete
                                 .equ	ADCCaddr	= 0x000e	; ADC Conversion Complete
                                 .equ	ERDYaddr	= 0x000f	; EEPROM Ready
                                 .equ	ACIaddr	= 0x0010	; Analog Comparator
                                 .equ	TWIaddr	= 0x0011	; 2-wire Serial Interface
                                 .equ	SPMRaddr	= 0x0012	; Store Program Memory Ready
                                 
                                 .equ	INT_VECTORS_SIZE	= 19	; size in words
                                 
                                 #pragma AVRPART CORE INSTRUCTIONS_NOT_SUPPORTED break
                                 
                                 #endif  /* _M8ADEF_INC_ */
                                 
                                 ; ***** END OF FILE ******************************************************
                                 
                                 
                                 ;***** Created: 2011-02-09 12:03 ******* Source: ATmega8A.xml ************
                                 ;*************************************************************************
                                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                                 ;* 
                                 ;* Number            : AVR000
                                 ;* File Name         : "m8Adef.inc"
                                 ;* Title             : Register/Bit Definitions for the ATmega8A
                                 ;* Date              : 2011-02-09
                                 ;* Version           : 2.35
                                 ;* Support E-mail    : avr@atmel.com
                                 ;* Target MCU        : ATmega8A
                                 ;* 
                                 ;* DESCRIPTION
                                 ;* When including this file in the assembly program file, all I/O register 
                                 ;* names and I/O register bit names appearing in the data book can be used.
                                 ;* In addition, the six registers forming the three data pointers X, Y and 
                                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                                 ;* SRAM is also defined 
                                 ;* 
                                 ;* The Register names are represented by their hexadecimal address.
                                 ;* 
                                 ;* The Register Bit names are represented by their bit number (0-7).
                                 ;* 
                                 ;* Please observe the difference in using the bit names with instructions
                                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                                 ;* (skip if bit in register set/cleared). The following example illustrates
                                 ;* this:
                                 ;* 
                                 ;* in    r16,PORTB             ;read PORTB latch
                                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                                 ;* out   PORTB,r16             ;output to PORTB
                                 ;* 
                                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                                 ;* rjmp  TOV0_is_set           ;jump if set
                                 ;* ...                         ;otherwise do something else
                                 ;*************************************************************************
                                 
                                 #ifndef _M8ADEF_INC_
                                 #endif  /* _M8ADEF_INC_ */
                                 
                                 ; ***** END OF FILE ******************************************************
                                 ;.include "ModbusLib.inc"
                                 .list 
                                 .equ BAUD = 57600							; Скорость для UART в Бодах
                                 .equ XTAL = 16000000						; Частота в герцах
                                 .equ UBRR_value = (XTAL/(BAUD*16))-1		; Расчитывание значения для регистра UBRR
                                 
                                 .equ BUF_LEN =32							; Размер буфера для передачи данных
                                 .equ READ_TIME = 4							; Время ожидания очередного пакета данных
                                 .equ DATA_MEMORY_SIZE = 64					; Размер памяти регистров
                                 
                                 .equ POL_Hi = 0xA0							;Два байта полинома для CRC
                                 .equ POL_Lo = 0x01
                                 
                                 .equ TemprAr_Size = 120
                                 
                                 .equ devise_address		=	AO_Data+1
                                 .equ temperature_max	=	AO_Data+2
                                 .equ temperature_min	=	AO_Data+4
                                 .equ TemprAr_index		=	AI_Data
                                 .equ temperature		=	AI_Data+2
                                 .def temp = r16
                                 .def sys = r17
                                 .def function= r18
                                 .def msg = r19
                                 .def lenght = r20
                                 .def CRCHi = r21					 ; Обозначение регистров
                                 .def CRCLo = r22
                                 
                                 .macro Read_Func ; Определение функции
                                 	push r16
                                 	in r16, SREG
                                 	push r16
                                 	push r17
                                 	push r19
                                 	push r21
                                 	push r22
                                 	;cli
                                 	cpi @0,0x01									; Чтение Discrete Outputs
                                 	breq find_ReadCoils
                                 	cpi @0,0x02									; Чтение Discrete Inputs
                                 	breq find_Read_DI		
                                 	cpi @0, 0x03								; Чтение Analog Outputs
                                 	breq find_Read_AO_Registers					
                                 	cpi @0, 0x04								; Чтение Analog Inputs
                                 	breq find_Read_AI_Registers
                                 	cpi @0,0x05									; Запись одного Discrete Output
                                 	breq find_WriteOneCoil						
                                 	cpi @0, 0x06								; Запись одного Analog Output
                                 	breq find_Write_One_AO_Register				
                                 	cpi @0,0x0f									; Запись нексольких Discrete Outputs
                                 	breq find_WriteSeveralCoils					
                                 	cpi @0,0x10									; Запись нексольких Analog Outputs
                                 	breq find_Write_Several_AO_Registers
                                 
                                 	brne find_NoCommand_Error
                                 	find_ReadCoils:
                                 		rjmp ReadCoils
                                 	find_Read_DI:
                                 		rjmp Read_DI
                                 	find_Read_AO_Registers:
                                 		rjmp Read_AO_Registers
                                 	find_Read_AI_Registers:
                                 		rjmp Read_AI_Registers
                                 	find_WriteOneCoil:
                                 		rjmp WriteOneCoil
                                 	find_WriteSeveralCoils:
                                 		rjmp WriteSeveralCoils
                                 	find_Write_One_AO_Register:
                                 		rjmp Write_One_AO_Register
                                 	find_Write_Several_AO_Registers:
                                 		rjmp Write_Several_AO_Registers
                                 	find_NoCommand_Error:
                                 		rjmp NoCommand_Error
                                 
                                 ;------------------------------------		;0x01
                                 	ReadCoils:								; ЧТЕНИЕ НЕСКОЛЬКИХ ДИСКРЕТНЫХ ВЫВОДОВ
                                 		ld XH, Z+
                                 		ld XL, Z+
                                 		cpi XH, 0x00						; Проверка адреса
                                 		brne RC_wrong_addres
                                 		cpi XL, 0x00
                                 		brlo RC_wrong_addres
                                 		cpi XL, 4
                                 		brsh RC_wrong_addres
                                 		ld r16, Z+			
                                 		cpi r16,0x00						; Проверка количества регистров
                                 		brne RC_wrong_count				
                                 		ld r16, Z+
                                 		cpi r16,0x01
                                 		brlo RC_wrong_count
                                 		ldi r17,DATA_MEMORY_SIZE-2			; Проверка чтения дискретных пинов не больше имеющихся
                                 		sub r17, XL	
                                 		cp r16, r17
                                 		brsh RC_wrong_count
                                 		rjmp RC_check_ok
                                 		;
                                 		RC_wrong_addres:
                                 			rjmp	WrongAddres_Error
                                 		RC_wrong_count:
                                 			rjmp	WrongValue_Error
                                 		;
                                 		RC_check_ok:
                                 		sts high_buf_addres, XH
                                 		sts low_buf_addres, XL
                                 		sts buf_bytes_count, r16
                                 		
                                 		st Y+, @0
                                 		; вычисление кол-ва байт на отправку
                                 		ldi r17, 0x00
                                 		ldi r19, 0xff
                                 		RC_calc_bytes:
                                 			inc r17
                                 			cpi r16,8
                                 			brlo RC_calc_bytes_end
                                 			subi r16,8
                                 			breq RC_calc_bytes_end
                                 			brne RC_calc_bytes
                                 		RC_calc_bytes_end:
                                 		st Y+, r17
                                 		inc lenght
                                 		mov r19, r17
                                 
                                 		lds r16,  low_buf_addres
                                 		ldi r17, 0x00
                                 		RC_calc_addresbytes:
                                 			inc r17
                                 			cpi r16,8
                                 			brlo RC_calc_addresbytes_end
                                 			subi r16,8
                                 			breq RC_calc_addresbytes_end
                                 			brne RC_calc_addresbytes
                                 		RC_calc_addresbytes_end:
                                 		
                                 		ldi XH,high(DO_data)
                                 		ldi XL,low(DO_data)
                                 		RC_addres_shift:
                                 			ld r21, X+
                                 			dec r17
                                 		brne RC_addres_shift
                                 		ld r22, X+					
                                 		cpi r16, 0x00
                                 		breq RC_shift_end
                                 		RC_shift:							; Выполняем свдиг до необходимого адреса в регистре
                                 			lsr r22
                                 			ror r21
                                 			dec r16
                                 		brne RC_shift
                                 		RC_shift_end:
                                 		ld r16,-X
                                 		ldi r16, 0x00
                                 		lds r17, buf_bytes_count			; Дополняем пакет данными
                                 		RC_bytes_mask:
                                 			sec
                                 			rol r16
                                 			dec r17
                                 		brne RC_bytes_mask
                                 		RC_Read_DI:
                                 			and r21, r16
                                 			st Y+, r21
                                 			inc lenght
                                 			mov r21, r22
                                 			ld r22, X+
                                 			dec r19
                                 		brne RC_Read_DI
                                 		sts out_offset, lenght
                                 		rjmp Read_Func_end
                                 
                                 ;------------------------------------		; 0x02
                                 	Read_DI:								; ЧТЕНИЕ НЕСКОЛЬКИХ ДИСКРЕТНЫХ ВВОДОВ
                                 		ld XH, Z+
                                 		ld XL, Z+
                                 		cpi XH, 0x00						; Проверка адреса
                                 		brne RDI_wrong_addres
                                 		cpi XL, 0x00
                                 		brlo RDI_wrong_addres
                                 		cpi XL, DATA_MEMORY_SIZE
                                 		brsh RDI_wrong_addres
                                 		ld r16, Z+			
                                 		cpi r16,0x00						; Проверка количества регистров
                                 		brne RDI_wrong_count				
                                 		ld r16, Z+
                                 		cpi r16,0x01
                                 		brlo RDI_wrong_count
                                 		ldi r17,DATA_MEMORY_SIZE-2			; Проверка чтения дискретных пинов не больше имеющихся
                                 		sub r17, XL	
                                 		cp r16, r17
                                 		brsh RDI_wrong_count
                                 		rjmp RDI_check_ok
                                 		;
                                 		RDI_wrong_addres:
                                 			rjmp	WrongAddres_Error
                                 		RDI_wrong_count:
                                 			rjmp	WrongValue_Error
                                 		;
                                 		RDI_check_ok:
                                 		sts high_buf_addres, XH
                                 		sts low_buf_addres, XL
                                 		sts buf_bytes_count, r16
                                 		
                                 		st Y+, @0
                                 		; вычисление кол-ва байт на отправку
                                 		ldi r17, 0x00
                                 		ldi r19, 0xff
                                 		RDI_calc_bytes:
                                 			inc r17
                                 			cpi r16,8
                                 			brlo RDI_calc_bytes_end
                                 			subi r16,8
                                 			breq RDI_calc_bytes_end
                                 			brne RDI_calc_bytes
                                 		RDI_calc_bytes_end:
                                 		st Y+, r17
                                 		inc lenght
                                 		mov r19, r17
                                 
                                 		lds r16,  low_buf_addres
                                 		ldi r17, 0x00
                                 		RDI_calc_addresbytes:
                                 			inc r17
                                 			cpi r16,8
                                 			brlo RDI_calc_addresbytes_end
                                 			subi r16,8
                                 			breq RDI_calc_addresbytes_end
                                 			brne RDI_calc_addresbytes
                                 		RDI_calc_addresbytes_end:
                                 		
                                 		ldi XH,high(DI_data)
                                 		ldi XL,low(DI_data)
                                 		RDI_addres_shift:
                                 			ld r21, X+
                                 			dec r17
                                 		brne RDI_addres_shift
                                 		ld r22, X+					
                                 		cpi r16, 0x00
                                 		breq RDI_shift_end
                                 		RDI_shift:							; Выполняем свдиг до необходимого адреса в регистре
                                 			lsr r22
                                 			ror r21
                                 			dec r16
                                 		brne RDI_shift
                                 		RDI_shift_end:
                                 		ld r16,-X
                                 		ldi r16, 0x00
                                 		lds r17, buf_bytes_count			; Дополняем пакет данными
                                 		RDI_bytes_mask:
                                 			sec
                                 			rol r16
                                 			dec r17
                                 		brne RDI_bytes_mask
                                 		RDI_Read_DI:
                                 			and r21, r16
                                 			st Y+, r21
                                 			inc lenght
                                 			mov r21, r22
                                 			ld r22, X+
                                 			dec r19
                                 		brne RDI_Read_DI
                                 		sts out_offset, lenght
                                 		rjmp Read_Func_end
                                 
                                 ;-------------------------------------------; 0x03
                                 	Read_AO_Registers:						; ЧТЕНИЕ АНАЛОГОВЫХ ВЫВОДОВ
                                 		ld XH, Z+
                                 		ld XL, Z+
                                 		cpi XH, 0x00						; Проверка адреса
                                 		brne RAO_wrong_addres
                                 		cpi XL, 0x00
                                 		brlo RAO_wrong_addres
                                 		cpi XL, DATA_MEMORY_SIZE/2
                                 		brsh RAO_wrong_addres
                                 		;RAO_Count_check
                                 		ld r17, Z+
                                 		ld r16, Z+
                                 		cpi r17, 0x00
                                 		brne RAO_wrong_count
                                 		cpi r16, 0x01
                                 		brlo RAO_wrong_count
                                 		mov r19, XL
                                 		add r19, r16
                                 		cpi r19, DATA_MEMORY_SIZE/2+1
                                 		brsh RAO_wrong_count
                                 		rjmp RAO_check_ok
                                 		;
                                 		RAO_wrong_addres:					; Переход в ошибки
                                 			rjmp	WrongAddres_Error
                                 		RAO_wrong_count:
                                 			rjmp	WrongAddres_Error
                                 		;
                                 		RAO_check_ok:
                                 		sts high_buf_addres, XH
                                 		sts low_buf_addres, XL
                                 		sts buf_bytes_count, r16
                                 		st Y+, @0
                                 		add r16, r16
                                 		st Y+, r16
                                 		lds r16,buf_bytes_count
                                 		inc lenght
                                 		ldi XH,high(AO_data)
                                 		ldi XL,low(AO_data)
                                 		lds r19, low_buf_addres
                                 		;sts temp_sram, r19
                                 		cpi r19,0x00
                                 		breq RAO_read_AO
                                 		RAO_addres_shift:
                                 			ld r17, X+
                                 			ld r17, X+
                                 			dec r19
                                 		brne RAO_addres_shift
                                 		RAO_read_AO:
                                 			ld r17, X+
                                 			;sts temp_sram, r17
                                 			st Y+, r17
                                 			inc lenght
                                 			ld r17, X+
                                 			st Y+, r17
                                 			inc lenght
                                 			dec r16
                                 		brne RAO_read_AO
                                 		rjmp Read_Func_end
                                 
                                 ;-------------------------------------------; 0x04
                                 	Read_AI_Registers:						; ЧТЕНИЕ АНАЛОГОВЫХ ВВОДОВ
                                 		ld XH, Z+
                                 		ld XL, Z+
                                 		cpi XH, 0x00						; Проверка адреса
                                 		brne RAI_wrong_addres
                                 		cpi XL, 0x00
                                 		brlo RAI_wrong_addres
                                 		cpi XL, DATA_MEMORY_SIZE/2
                                 		brsh RAI_wrong_addres
                                 		;RAO_Count_check
                                 		ld r17, Z+
                                 		ld r16, Z+
                                 		cpi r17, 0x00
                                 		brne RAI_wrong_count
                                 		cpi r16, 0x01
                                 		brlo RAI_wrong_count
                                 		mov r19, XL
                                 		add r19, r16
                                 		cpi r19, DATA_MEMORY_SIZE/2+1
                                 		brsh RAI_wrong_count
                                 		rjmp RAI_check_ok
                                 		;
                                 		RAI_wrong_addres:					; Переход в ошибки
                                 			rjmp	WrongAddres_Error
                                 		RAI_wrong_count:
                                 			rjmp	WrongAddres_Error
                                 		;
                                 		RAI_check_ok:
                                 		sts high_buf_addres, XH
                                 		sts low_buf_addres, XL
                                 		sts buf_bytes_count, r16
                                 		st Y+, @0
                                 		add r16, r16
                                 		st Y+, r16
                                 		lds r16,buf_bytes_count
                                 		inc lenght
                                 		ldi XH,high(AI_data)
                                 		ldi XL,low(AI_data)
                                 		lds r19, low_buf_addres
                                 		;sts temp_sram, r19
                                 		cpi r19,0x00
                                 		breq RAO_read_AO
                                 		RAI_addres_shift:
                                 			ld r17, X+
                                 			ld r17, X+
                                 			dec r19
                                 		brne RAI_addres_shift
                                 		RAI_read_AO:
                                 			ld r17, X+
                                 			;sts temp_sram, r17
                                 			st Y+, r17
                                 			inc lenght
                                 			ld r17, X+
                                 			st Y+, r17
                                 			inc lenght
                                 			dec r16
                                 		brne RAI_read_AO
                                 		rjmp Read_Func_end
                                 
                                 ;------------------------------------------ ;0x05
                                 	WriteOneCoil:							; ЗАПИСЬ ЗНАЧЕНИЯ В ОДИН ДИСКРЕТНЫЙ ВЫВОД
                                 		ld XH, Z+
                                 		ld XL, Z+
                                 		cpi XH, 0x00						; Проверка адреса
                                 		brne WOC_wrong_addres
                                 		cpi XL, 0x00
                                 		brlo WOC_wrong_addres
                                 		cpi XL, 6
                                 		brsh WOC_wrong_addres
                                 		;WOC_Value_check:
                                 		ld r17, Z+							; Проверка вводимого значения
                                 		ld r16, Z+
                                 		cpi XL,5
                                 		breq WOC_reset_request
                                 		cpi r16,0x00
                                 		brne WOC_wrong_count
                                 		cpi r17,0x00
                                 		breq WOC_count_ok
                                 		cpi r17,0xff
                                 		breq WOC_count_ok
                                 		rjmp WOC_wrong_count
                                 			
                                 		WOC_count_ok:
                                 			st Y+, function
                                 			st Y+, XH
                                 			inc lenght
                                 			st Y+, XL
                                 			inc lenght
                                 			st Y+, r17
                                 			inc lenght
                                 			st Y+, r16
                                 			inc lenght
                                 			ldi r22,0x01
                                 			mov r21, XL
                                 			cpi r21, 0x00
                                 			breq WOC_shift_end
                                 			WOC_shift:
                                 				lsl r22
                                 				dec r21
                                 			brne WOC_shift
                                 			WOC_shift_end:
                                 			
                                 			ldi XH,high(DO_data)
                                 			ldi XL,low(DO_data)
                                 
                                 			cpi r17, 0xff
                                 			brne clr_WOC
                                 				ld r16, X+
                                 				or r16, r22
                                 				st -X,r16
                                 				sts out_offset, lenght
                                 				rjmp Read_Func_end
                                 			clr_WOC:
                                 				com r22
                                 				ld r16, X+ ;PORTC
                                 				and r16, r22
                                 				st -X,r16	;PORTC
                                 				sts out_offset, lenght
                                 				rjmp Read_Func_end
                                 			WOC_reset_request:
                                 				cpi r17, 0xff
                                 				brne WOC_wrong_count
                                 				rjmp Reset
                                 		WOC_wrong_addres:
                                 			rjmp	WrongAddres_Error
                                 		WOC_wrong_count:
                                 			rjmp	WrongValue_Error
                                 ;-------------------------------------------;0x06
                                 	Write_One_AO_Register:					; ЗАПИСЬ ОДНОГО АНАЛОГОВОГО ВЫВОДА
                                 		ld XH, Z+
                                 		ld XL, Z+
                                 		cpi XH, 0x00						; Проверка адреса
                                 		brne W1AO_wrong_addres
                                 		cpi XL, 0x00
                                 		brlo W1AO_wrong_addres
                                 		cpi XL, DATA_MEMORY_SIZE/2
                                 		brsh W1AO_wrong_addres
                                 		ld r17, Z+
                                 		ld r16, Z+
                                 		rjmp W1AO_check_ok
                                 		;
                                 		W1AO_wrong_addres:
                                 			rjmp	WrongAddres_Error
                                 		W1AO_Wrong_Value:
                                 			rjmp	WrongValue_Error
                                 		;
                                 		W1AO_check_ok:
                                 			st Y+, function
                                 			st Y+, XH
                                 			inc lenght
                                 			st Y+, XL
                                 			inc lenght
                                 			st Y+, r17
                                 			inc lenght
                                 			st Y+, r16
                                 			inc lenght
                                 			mov r19, XL
                                 			ldi XH,high(AO_data)
                                 			ldi XL,low(AO_data)
                                 		/*	cpi r19,0x00
                                 			breq W1AO_writeEEPROM_DevAdd
                                 			cpi r19,0x01
                                 			breq W1AO_writeEEPROM_TemMin
                                 			cpi r19,0x02
                                 			breq W1AO_writeEEPROM_TemMax*/
                                 			rjmp W1AO_input_data
                                 
                                 			/*
                                 			;Ввод в EEPROM
                                 			;Ввод нового адреса устройства
                                 			W1AO_writeEEPROM_DevAdd:
                                 				cpi r16, 0x00
                                 					breq W1AO_Wrong_Value
                                 				cpi r16, 0xF8
                                 					brsh W1AO_Wrong_Value
                                 				sts eeprom_data, r16
                                 				ldi r21,0x00
                                 				sts eeprom_address, r21
                                 				ldi r21,0x01
                                 				sts eeprom_flag, r21
                                 				sts devise_address, r16
                                 				;EEWrite r16
                                 				rjmp W1AO_input_data
                                 			;Ввод нижней границы температуры
                                 			W1AO_writeEEPROM_TemMin:
                                 				lds r21,temperature_max
                                 				cp r16, r21
                                 					brlo W1AO_Wrong_Value
                                 				;EEWrite r16
                                 				sts eeprom_data, r16
                                 				ldi r21,0x01
                                 				sts eeprom_address, r21
                                 				ldi r21,0x01
                                 				sts eeprom_flag, r21
                                 				sts temperature_min, r16
                                 				rjmp W1AO_input_data
                                 			;Ввод верхней границы температуры
                                 			W1AO_writeEEPROM_TemMax:
                                 				lds r21,temperature_min
                                 				cp r16, r21
                                 					brsh W1AO_Wrong_Value
                                 				;EEWrite r16
                                 				sts eeprom_data, r16
                                 				ldi r21,0x02
                                 				sts eeprom_address, r21
                                 				ldi r21,0x01
                                 				sts eeprom_flag, r21
                                 				sts temperature_max, r16
                                 				rjmp W1AO_input_data
                                 
                                 				*/
                                 
                                 			W1AO_input_data:
                                 			cpi r19,0x00
                                 				breq W1AO_write_AO
                                 			W1AO_addres_shift:
                                 				ld r21, X+
                                 				ld r21, X+
                                 				dec r19
                                 			brne W1AO_addres_shift
                                 			W1AO_write_AO:
                                 				st X+, r17
                                 				st X+, r16
                                 			rjmp Read_Func_end
                                 
                                 ;-------------------------------------------;0x0F
                                 	WriteSeveralCoils:						; ЗАПИСЬ НЕСКОЛЬКИХ ДИСКРЕТНЫХ ВЫВОДОВ	
                                 
                                 		ld XH, Z+
                                 		ld XL, Z+
                                 		cpi XH, 0x00						; Проверка адреса
                                 		brne WSC_Wrong_Addres
                                 		cpi XL, 0x00
                                 		brlo WSC_Wrong_Addres
                                 		cpi XL, 5
                                 		brsh WSC_Wrong_Addres
                                 		
                                 		sts high_buf_addres, XH 
                                 		sts low_buf_addres, XL 
                                 
                                 		ld r16, Z+			
                                 		cpi r16,0x00						; Проверка количества регистров
                                 		brne WSC_Wrong_Count
                                 		sts high_buf_registers_count, r16
                                 		ld r16, Z+
                                 		cpi r16,0x01
                                 		brlo WSC_Wrong_Count
                                 		ldi r17,6							; Проверка чтения дискретных пинов не больше имеющихся
                                 		sub r17, XL	
                                 		cp r16, r17
                                 		brsh WSC_Wrong_Count
                                 		sts low_buf_registers_count, r16
                                 		ld r17,Z+
                                 		sts buf_bytes_count,r17				; Проверка кол-ва следующих байтов
                                 		cpi r17, 0							; если кол-во равно 0, то присвоить 1
                                 		brne WSC_CheckBytesCount
                                 			inc r17
                                 			sts buf_bytes_count,r17
                                 			rjmp WSC_CheckEnd
                                 		WSC_CheckBytesCount:
                                 			
                                 			ldi r19, 8
                                 			mul r19, r17
                                 
                                 			cp r19, r16
                                 			brlo WSC_Wrong_Value
                                 			subi r19,8
                                 			cp r19, r16
                                 			brsh WSC_Wrong_Value
                                 			sts buf_bytes_count,r17
                                 			rjmp WSC_CheckEnd
                                 		;
                                 		WSC_Wrong_Addres:					; Переход при ошибке
                                 			rjmp	WrongAddres_Error
                                 		WSC_Wrong_Count:
                                 			rjmp	WrongValue_Error
                                 		WSC_Wrong_Value:
                                 			rjmp	WrongCount_Error
                                 		;
                                 		ldi XH,high(DO_data)
                                 		ldi XL,low(DO_data)
                                 		WSC_CheckEnd:						; Окончание проверки
                                 			lds r16, low_buf_addres			; Адрес первого DO
                                 			lds r17, low_buf_registers_count; Количество записываемых DO
                                 			lds r23, buf_bytes_count
                                 		WSC_setbytes_loop:					; Цикл прохода по введённым байтам
                                 			ldi r19,0xff
                                 			ld r19,Z+
                                 			cpi r17, 8
                                 			brsh WCS_shift_MT8		
                                 			WSC_OneShift:
                                 				ld r21, X+ ; in r21, PORTC
                                 				cpi r16,0
                                 				breq WSC_AddShift_end
                                 			WSC_AddShift:
                                 				lsr r21
                                 				ror r22
                                 				dec r16
                                 			brne WSC_AddShift
                                 				lds r16, low_buf_addres
                                 			WSC_AddShift_sec:
                                 				lsl r22
                                 				rol r19
                                 				dec r16
                                 			brne WSC_AddShift_sec
                                 				lds r16, low_buf_addres
                                 			WSC_AddShift_third:
                                 				lsl r21
                                 				dec r16
                                 			brne WSC_AddShift_third
                                 			WSC_AddShift_end:
                                 				lds r16, low_buf_addres
                                 				add r16,r17
                                 				ldi r17, 8
                                 				sub r17, r16
                                 				mov r16,r17
                                 			WSC_RightByteShift:
                                 				lsl r19
                                 				dec r16
                                 			brne WSC_RightByteShift
                                 				mov r16,r17
                                 				ldi r22,0x00
                                 			WSC_RightByteShift_sec:
                                 				lsl r21
                                 				rol r22
                                 				dec r16
                                 			brne WSC_RightByteShift_sec
                                 				mov r16,r17
                                 			WSC_RightByteShift_third:
                                 				lsr r22
                                 				ror r19
                                 				dec r16
                                 			brne WSC_RightByteShift_third
                                 				ldi XH,high(DO_data)
                                 				ldi XL,low(DO_data)
                                 				st X, r19	;out PORTC, r19	
                                 				rjmp WCS_shift_end
                                 			WCS_shift_MT8:
                                 				ldi XH,high(DO_data)
                                 				ldi XL,low(DO_data)
                                 				ld r22, X+	; in r22,PORTC
                                 				and r22,r19
                                 				st -X, r22	; out PORTC,r22
                                 				subi r17,8				
                                 			WCS_shift_end:
                                 			pop r17
                                 			lds r17, buf_bytes_count
                                 			dec r17
                                 			sts buf_bytes_count, r17
                                 			push r17
                                 		brne WSC_setbytes_loop
                                 		st Y+, function
                                 		lds r16, high_buf_addres
                                 		st Y+, r16
                                 		inc lenght
                                 		lds r16, low_buf_addres
                                 		st Y+, r16
                                 		inc lenght
                                 		lds r16, high_buf_registers_count
                                 		st Y+, r16
                                 		inc lenght
                                 		lds r16, low_buf_registers_count
                                 		st Y+, r16
                                 		inc lenght
                                 		sts out_offset, lenght
                                 		rjmp Read_Func_end
                                 
                                 
                                 ;-------------------------------------------; 0x10 ЗАПИСЬ НЕСКОЛЬКИХ АНАЛОГОВЫХ ВЫВОДОВ
                                 	Write_Several_AO_Registers:
                                 		ld XH, Z+
                                 		ld XL, Z+
                                 		cpi XH, 0x00						; Проверка адреса
                                 		brne WSAO_wrong_addres
                                 		cpi XL, 0x00
                                 		brlo WSAO_wrong_addres
                                 		cpi XL, DATA_MEMORY_SIZE/2
                                 		brsh WSAO_wrong_addres
                                 		;WSAO_Count_check
                                 		ld r17, Z+
                                 		ld r16, Z+
                                 		cpi r17, 0x00
                                 		brne WSAO_wrong_count
                                 		cpi r16, 0x01
                                 		brlo WSAO_wrong_count
                                 		mov r19, XL
                                 		add r19, r16
                                 		cpi r19, DATA_MEMORY_SIZE/2+1
                                 		brsh WSAO_wrong_count
                                 		ld r19, Z+
                                 		mov r21, r16
                                 		add r21, r16
                                 		cp r21, r19
                                 		brne WSAO_wrong_count
                                 		rjmp WSAO_check_ok
                                 		;
                                 		WSAO_wrong_addres:					; При ошибке передходим в exception
                                 			rjmp	WrongAddres_Error
                                 		WSAO_wrong_count:
                                 			rjmp	WrongAddres_Error
                                 		;
                                 		WSAO_check_ok:
                                 			sts high_buf_addres, XH 
                                 			sts low_buf_addres, XL 
                                 			sts buf_bytes_count, r19
                                 			st Y+, function
                                 			st Y+, XH
                                 			inc lenght
                                 			st Y+, XL
                                 			inc lenght
                                 			st Y+, r17
                                 			inc lenght
                                 			st Y+, r16
                                 			inc lenght
                                 			ldi XH,high(AO_data)
                                 			ldi XL,low(AO_data)
                                 			lds r21, low_buf_addres
                                 			add r21, r21
                                 			cpi r21, 0x00
                                 			breq WSAO_write_AO_bytes
                                 			WSAO_addres_shift:
                                 				ld r22,X+
                                 				dec r21
                                 				brne WSAO_addres_shift
                                 			WSAO_write_AO_bytes:
                                 				ld r22, Z+
                                 				st X+, r22
                                 				dec r19
                                 			brne WSAO_write_AO_bytes
                                 			;ldi	r19,	0x01
                                 			;lds	eeprom_flag,	r19
                                 			rjmp Read_Func_end
                                 
                                 ;--------------- ВЫВОД ОШИБОК------------------------;
                                 	NoCommand_Error:						 
                                 		Func_Error @0,1
                                 		rjmp Read_Func_end
                                 	WrongAddres_Error:
                                 		Func_Error @0,2
                                 		rjmp Read_Func_end
                                 	WrongValue_Error:
                                 		Func_Error @0,3
                                 		rjmp Read_Func_end
                                 	WrongCount_Error:
                                 		Func_Error @0,3
                                 		rjmp Read_Func_end
                                   Read_Func_end:
                                 	pop r22
                                 	pop r21
                                 	pop r19
                                 	pop r17
                                 	pop r16
                                 	out SREG, r16
                                 	pop r16
                                 	;sei
                                 .endm
                                 
                                 
                                 .macro Func_Error		; @0 - код изначальной функции, @1 - excepction код
                                 	push r19
                                 		ldi r19, 0x80
                                 		add r19, @0
                                 		st Y+, r19
                                 		ldi r19, @1
                                 		st Y+, r19
                                 		lds r19, out_offset
                                 		inc r19
                                 		sts out_offset, r19
                                 		inc lenght
                                 	pop r19
                                 .endm
                                 
                                 .macro crc16  ; Вычисление СRC по каждому байту (передаётся регистр)
                                 	push r16
                                 	push r17
                                 
                                 	mov r16, @0
                                 	ldi r17, 8
                                 	eor CRCLo, r16
                                 	crc_loop:
                                 	
                                 	LSR CRCHi
                                 	ROR CRCLo
                                 	brcc zer1
                                 
                                 	ldi r16, POL_Hi
                                 	eor CRCHi, r16
                                 	ldi r16, POL_Lo
                                 	eor CRCLo, r16
                                 
                                 	zer1:
                                 	dec r17
                                 	brne crc_loop
                                 
                                 	pop r17
                                 	pop r16
                                 
                                 .endm
                                 
                                 .macro USART_Trancieve // Передача одного байта
                                 push r16
                                 trans_loop:
                                 	in r16, UCSRA
                                 	sbrs r16, UDRE					; Проверяем, не занят ли буфер передачи USART
                                 	rjmp trans_loop
                                 	out UDR,@0						; Передаём байт+
                                 pop r16
                                 .endm
                                 
                                 ;Чтение из EEPROM
                                 .macro EERead				; @0 - Address byte
                                 	EERead_loop:
                                 	sbic 	EECR,EEWE		; Ждем пока будет завершена прошлая запись.
                                 	rjmp	EERead_loop		; также крутимся в цикле.
                                 	push	r16
                                 	PushSREG
                                 	;cli
                                 	;push r16
                                 	push r24
                                 
                                 	ldi		r24, 0x00
                                 	out		EEARH, r24		; загружаем адрес нужной ячейки
                                 	ldi		r24, @0
                                 	out 	EEARL, r24
                                 	;out  	EEARH, low(@0) 		; его старшие и младшие байты
                                 	sbi 	EECR,EERE 		; Выставляем бит чтения
                                 	in 		r24, EEDR 		; Забираем из регистра данных результат
                                 	sts eeprom_data, r24
                                 	nop
                                 	nop
                                 	nop
                                 	nop
                                 	pop r24
                                 	;pop	r16
                                 	PopSREG
                                 	pop		r16
                                 	;sei
                                 .endm
                                 
                                 ;Запись в EEPROM
                                 .macro EEWrite				; @0 - Address byte, @1 - Data
                                 	EEWrite_loop:
                                 	sbic	EECR,EEWE		; Ждем готовности памяти к записи. Крутимся в цикле
                                 	rjmp	EEWrite_loop 		; до тех пор пока не очистится флаг EERE
                                  
                                 	;cli				; Затем запрещаем прерывания.
                                 	push	r16
                                 	PushSREG
                                 	push	r23
                                 	push	r24
                                 	;push r17
                                 	;push r21
                                 	ldi		r24, 0x00
                                 	out		EEARH, r24
                                 	lds		r24,	eeprom_address
                                 	;mov		r24, @0
                                 	out 	EEARL, r24 		; Загружаем адрес нужной ячейки
                                 	;ldi		r16, high(@0)
                                 	;out 	EEARH, r16  		; старший и младший байт адреса
                                 	lds		r24,	eeprom_data
                                 	out 	EEDR,	r24;@1 		; и сами данные, которые нам нужно загрузить
                                 
                                 	sbi 	EECR,EEMWE		; взводим предохранитель
                                 	sbi 	EECR,EEWE		; записываем байт
                                 	nop
                                 	nop
                                 	nop
                                 	nop
                                 	;pop r21
                                 	;pop r17
                                 	pop r24
                                 	pop	r23
                                 	;sei 				    ; разрешаем прерывания
                                 	PopSREG
                                 	pop		r16
                                 .endm 				        ; возврат из процедуры
                                  
                                 
                                  ;	Сохранение регистра SREG в стек
                                  .macro PushSREG
                                 	;push r16
                                 	in r16, SREG
                                 	push r16
                                 	ldi r16,0x00
                                 	out SREG, r16
                                 .endm
                                 ;	И его выгрузка из стека
                                 .macro PopSREG
                                 	pop r16
                                 	out SREG, r16
                                 	;pop r16
                                 .endm
                                  
                                 ; Блок Данных
                                 .dseg 
                                 .org $100
                                 ;temp_sram: .BYTE 1
                                 ;temperature: .BYTE 1
                                 
000100                           in_data: .BYTE BUF_LEN				; Буфер принятых данных
000120                           in_offset: .BYTE 1					; Смещение в буфере при принятии
000121                           in_flag: .BYTE 1					; флаг для чтения пакета(0 при конце пакета)
000122                           in_count: .BYTE 1					; число принятых байтов
                                 
000123                           out_data: .BYTE BUF_LEN				; Буфер данных для отправки
000143                           out_offset: .BYTE 1					; Смещение в буфере при передаче
000144                           out_flag: .BYTE 1					; Флаг по окончании передачи пакета
000145                           high_buf_addres: .BYTE 1			; Буфер для первого адреса
000146                           low_buf_addres: .BYTE 1
000147                           high_buf_registers_count: .BYTE 1	; Буфер для хранения количества регистров
000148                           low_buf_registers_count: .BYTE 1
000149                           buf_bytes_count: .BYTE 1			; Буфер для хранения количества передаваемых байтов
                                 
00014a                           eeprom_data: .BYTE 1
00014b                           eeprom_address: .BYTE 1
00014c                           eeprom_flag: .BYTE 1
                                 
00014d                           system_reg:	.BYTE 1
                                 ;TemprAr_index:	.BYTE 1
00014e                           prev_devise_address: .BYTE 1				; Адрес устройства
00014f                           prev_temperature_min: .BYTE 2	
000151                           prev_temperature_max: .BYTE 2
                                 ;temperature: .BYTE 2
                                 ;temperature_data: .BYTE 2			; Дынные с датчика температуры
                                 
000153                           DO_data: .BYTE DATA_MEMORY_SIZE					; Discrete Output Coils (чтение/запись)
000193                           DI_data: .BYTE DATA_MEMORY_SIZE					; Discrete Input Coils (чтение)
0001d3                           AI_data: .BYTE DATA_MEMORY_SIZE					; Analog Input Coils (чтение)
000213                           AO_data: .BYTE DATA_MEMORY_SIZE					; Analog Output Coils (чтение/запись)
                                 
                                 ; Блок кода
                                 .cseg
                                 		 .org $000        	; (RESET) 
000000 c087                               RJMP Reset
                                 		 .org $004
000004 c58a                      		 RJMP TIMER2_OVF
                                 		;.org $008
                                 		 ;RJMP TIMER1_OVF
                                 		 .org $009
000009 c5b7                      		 RJMP TIMER0_OVF
                                 		 .org $00b
00000b c566                      		 rjmp USART_RXC
                                 		 .org $00E
00000e c505                      		 rjmp ADC_Conv_Complete
                                 
                                 		 /*
                                 TempAr_Temp:
                                 .db		0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,
                                 		50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,
                                 		100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119, 120
                                 ;*/
                                 TemprAr_Values:
00000f 03e2                      .dw		0b0000001111100010	;0
000010 03e0                      .dw		0b0000001111100000	;1
000011 03df                      .dw		0b0000001111011111	;2
000012 03dd                      .dw		0b0000001111011101	;3
000013 03db                      .dw		0b0000001111011011	;4
000014 03d9                      .dw		0b0000001111011001	;5
000015 03d8                      .dw		0b0000001111011000	;6
000016 03d6                      .dw		0b0000001111010110	;7
000017 03d4                      .dw		0b0000001111010100	;8
000018 03d1                      .dw		0b0000001111010001	;9
000019 03cf                      .dw		0b0000001111001111	;10
00001a 03cd                      .dw		0b0000001111001101	;11
00001b 03ca                      .dw		0b0000001111001010	;12
00001c 03c8                      .dw		0b0000001111001000	;13
00001d 03c5                      .dw		0b0000001111000101	;14
00001e 03c3                      .dw		0b0000001111000011	;15
00001f 03c0                      .dw		0b0000001111000000	;16
000020 03bd                      .dw		0b0000001110111101	;17
000021 03ba                      .dw		0b0000001110111010	;18
000022 03b7                      .dw		0b0000001110110111	;19
000023 03b4                      .dw		0b0000001110110100	;20
000024 03b1                      .dw		0b0000001110110001	;21
000025 03ad                      .dw		0b0000001110101101	;22
000026 03aa                      .dw		0b0000001110101010	;23
000027 03a6                      .dw		0b0000001110100110	;24
000028 03a2                      .dw		0b0000001110100010	;25
000029 039f                      .dw		0b0000001110011111	;26
00002a 039b                      .dw		0b0000001110011011	;27
00002b 0397                      .dw		0b0000001110010111	;28
00002c 0392                      .dw		0b0000001110010010	;29
00002d 038e                      .dw		0b0000001110001110	;30
00002e 038a                      .dw		0b0000001110001010	;31
00002f 0385                      .dw		0b0000001110000101	;32
000030 0381                      .dw		0b0000001110000001	;33
000031 037c                      .dw		0b0000001101111100	;34
000032 0377                      .dw		0b0000001101110111	;35
000033 0372                      .dw		0b0000001101110010	;36
000034 036d                      .dw		0b0000001101101101	;37
000035 0368                      .dw		0b0000001101101000	;38
000036 0362                      .dw		0b0000001101100010	;39
000037 035d                      .dw		0b0000001101011101	;40
000038 0357                      .dw		0b0000001101010111	;41
000039 0352                      .dw		0b0000001101010010	;42
00003a 034c                      .dw		0b0000001101001100	;43
00003b 0346                      .dw		0b0000001101000110	;44
00003c 0340                      .dw		0b0000001101000000	;45
00003d 033a                      .dw		0b0000001100111010	;46
00003e 0334                      .dw		0b0000001100110100	;47
00003f 032d                      .dw		0b0000001100101101	;48
000040 0327                      .dw		0b0000001100100111	;49
000041 0320                      .dw		0b0000001100100000	;50
000042 031a                      .dw		0b0000001100011010	;51
000043 0313                      .dw		0b0000001100010011	;52
000044 030c                      .dw		0b0000001100001100	;53
000045 0305                      .dw		0b0000001100000101	;54
000046 02fe                      .dw		0b0000001011111110	;55
000047 02f7                      .dw		0b0000001011110111	;56
000048 02f0                      .dw		0b0000001011110000	;57
000049 02e9                      .dw		0b0000001011101001	;58
00004a 02e1                      .dw		0b0000001011100001	;59
00004b 02da                      .dw		0b0000001011011010	;60
00004c 02d2                      .dw		0b0000001011010010	;61
00004d 02cb                      .dw		0b0000001011001011	;62
00004e 02c3                      .dw		0b0000001011000011	;63
00004f 02bb                      .dw		0b0000001010111011	;64
000050 02b4                      .dw		0b0000001010110100	;65
000051 02ac                      .dw		0b0000001010101100	;66
000052 02a4                      .dw		0b0000001010100100	;67
000053 029c                      .dw		0b0000001010011100	;68
000054 0294                      .dw		0b0000001010010100	;69
000055 028c                      .dw		0b0000001010001100	;70
000056 0285                      .dw		0b0000001010000101	;71
000057 027d                      .dw		0b0000001001111101	;72
000058 0275                      .dw		0b0000001001110101	;73
000059 026d                      .dw		0b0000001001101101	;74
00005a 0265                      .dw		0b0000001001100101	;75
00005b 025d                      .dw		0b0000001001011101	;76
00005c 0254                      .dw		0b0000001001010100	;77
00005d 024c                      .dw		0b0000001001001100	;78
00005e 0244                      .dw		0b0000001001000100	;79
00005f 023c                      .dw		0b0000001000111100	;80
000060 0234                      .dw		0b0000001000110100	;81
000061 022d                      .dw		0b0000001000101101	;82
000062 0225                      .dw		0b0000001000100101	;83
000063 021d                      .dw		0b0000001000011101	;84
000064 0215                      .dw		0b0000001000010101	;85
000065 020d                      .dw		0b0000001000001101	;86
000066 0205                      .dw		0b0000001000000101	;87
000067 01fd                      .dw		0b0000000111111101	;88
000068 01f6                      .dw		0b0000000111110110	;89
000069 01ee                      .dw		0b0000000111101110	;90
00006a 01e6                      .dw		0b0000000111100110	;91
00006b 01df                      .dw		0b0000000111011111	;92
00006c 01d7                      .dw		0b0000000111010111	;93
00006d 01d0                      .dw		0b0000000111010000	;94
00006e 01c8                      .dw		0b0000000111001000	;95
00006f 01c1                      .dw		0b0000000111000001	;96
000070 01ba                      .dw		0b0000000110111010	;97
000071 01b2                      .dw		0b0000000110110010	;98
000072 01ab                      .dw		0b0000000110101011	;99
000073 01a4                      .dw		0b0000000110100100	;100
000074 019d                      .dw		0b0000000110011101	;101
000075 0196                      .dw		0b0000000110010110	;102
000076 0190                      .dw		0b0000000110010000	;103
000077 0189                      .dw		0b0000000110001001	;104
000078 0182                      .dw		0b0000000110000010	;105
000079 017b                      .dw		0b0000000101111011	;106
00007a 0175                      .dw		0b0000000101110101	;107
00007b 016e                      .dw		0b0000000101101110	;108
00007c 0168                      .dw		0b0000000101101000	;109
00007d 0162                      .dw		0b0000000101100010	;110
00007e 015c                      .dw		0b0000000101011100	;111
00007f 0156                      .dw		0b0000000101010110	;112
000080 0150                      .dw		0b0000000101010000	;113
000081 014a                      .dw		0b0000000101001010	;114
000082 0144                      .dw		0b0000000101000100	;115
000083 013e                      .dw		0b0000000100111110	;116
000084 0138                      .dw		0b0000000100111000	;117
000085 0133                      .dw		0b0000000100110011	;118
000086 012d                      .dw		0b0000000100101101	;119
000087 0128                      .dw		0b0000000100101000	;120
                                 
                                 /*
                                 
                                 0		0000001111100010
                                 1		0000001111100000
                                 2		0000001111011111
                                 3		0000001111011101
                                 4		0000001111011011
                                 5		0000001111011001
                                 6		0000001111011000
                                 7		0000001111010110
                                 8		0000001111010100
                                 9		0000001111010001
                                 10		0000001111001111
                                 11		0000001111001101
                                 12		0000001111001010
                                 13		0000001111001000
                                 14		0000001111000101
                                 15		0000001111000011
                                 16		0000001111000000
                                 17		0000001110111101
                                 18		0000001110111010
                                 19		0000001110110111
                                 20		0000001110110100
                                 21		0000001110110001
                                 22		0000001110101101
                                 23		0000001110101010
                                 24		0000001110100110
                                 25		0000001110100010
                                 26		0000001110011111
                                 27		0000001110011011
                                 28		0000001110010111
                                 29		0000001110010010
                                 30		0000001110001110
                                 31		0000001110001010
                                 32		0000001110000101
                                 33		0000001110000001
                                 34		0000001101111100
                                 35		0000001101110111
                                 36		0000001101110010
                                 37		0000001101101101
                                 38		0000001101101000
                                 39		0000001101100010
                                 40		0000001101011101
                                 41		0000001101010111
                                 42		0000001101010010
                                 43		0000001101001100
                                 44		0000001101000110
                                 45		0000001101000000
                                 46		0000001100111010
                                 47		0000001100110100
                                 48		0000001100101101
                                 49		0000001100100111
                                 50		0000001100100000
                                 51		0000001100011010
                                 52		0000001100010011
                                 53		0000001100001100
                                 54		0000001100000101
                                 55		0000001011111110
                                 56		0000001011110111
                                 57		0000001011110000
                                 58		0000001011101001
                                 59		0000001011100001
                                 60		0000001011011010
                                 61		0000001011010010
                                 62		0000001011001011
                                 63		0000001011000011
                                 64		0000001010111011
                                 65		0000001010110100
                                 66		0000001010101100
                                 67		0000001010100100
                                 68		0000001010011100
                                 69		0000001010010100
                                 70		0000001010001100
                                 71		0000001010000101
                                 72		0000001001111101
                                 73		0000001001110101
                                 74		0000001001101101
                                 75		0000001001100101
                                 76		0000001001011101
                                 77		0000001001010100
                                 78		0000001001001100
                                 79		0000001001000100
                                 80		0000001000111100
                                 81		0000001000110100
                                 82		0000001000101101
                                 83		0000001000100101
                                 84		0000001000011101
                                 85		0000001000010101
                                 86		0000001000001101
                                 87		0000001000000101
                                 88		0000000111111101
                                 89		0000000111110110
                                 90		0000000111101110
                                 91		0000000111100110
                                 92		0000000111011111
                                 93		0000000111010111
                                 94		0000000111010000
                                 95		0000000111001000
                                 96		0000000111000001
                                 97		0000000110111010
                                 98		0000000110110010
                                 99		0000000110101011
                                 100		0000000110100100
                                 101		0000000110011101
                                 102		0000000110010110
                                 103		0000000110010000
                                 104		0000000110001001
                                 105		0000000110000010
                                 106		0000000101111011
                                 107		0000000101110101
                                 108		0000000101101110
                                 109		0000000101101000
                                 110		0000000101100010
                                 111		0000000101011100
                                 112		0000000101010110
                                 113		0000000101010000
                                 114		0000000101001010
                                 115		0000000101000100
                                 116		0000000100111110
                                 117		0000000100111000
                                 118		0000000100110011
                                 119		0000000100101101
                                 120		0000000100101000
                                 
                                 */
                                 ;0x00 0x04 0x04 0x00 0x34 0x03 0x1A 0x2B 0xB1
                                 Reset:
                                 
000088 e004                      ldi temp, High(Ramend)
000089 bf0e                      out sph, temp
00008a e50f                      ldi temp, Low(Ramend)
00008b bf0d                      out spl,temp
                                 
00008c ef5f                      ldi CRCHi,0xFF ; CrcIn
00008d ef6f                      ldi CRCLo,0xFF
                                 
00008e e0f0                      ldi r31,0x00
00008f e6e0                      ldi r30,0x60
000090 e002                      ldi r16,0x02
000091 e030                      ldi r19,0x00
                                 mem_cl:
000092 ef1f                        ldi r17,0xff
                                   mem_cl2:					; ОЧИЩАЕМ ПАМЯТЬ ПЕРЕД РАБОТОЙ 2*256 = 512 байт	st Z+,r19
000093 9331                      	st Z+, r19
000094 951a                      	dec r17
000095 f7e9                      	brne mem_cl2
000096 950a                        dec r16
000097 f7d1                      brne mem_cl
                                 
                                 
                                 ; Настройка АЦП
000098 e400                      ldi		temp,	(0<<REFS1)|(1<<REFS0)|(0<<ADLAR)|(0<<MUX0);0b01100000
000099 b907                      out		ADMUX,	temp
00009a ec0f                      ldi		temp,	(1<<ADEN)|(1<<ADSC)/*|(0<<ADATE)*/|(0<<ADIF)|(1<<ADIE)|(7<<ADPS0);0b11001111
00009b b906                      out		ADCSRA, temp
                                 ;TIMER0 Settings
00009c e005                      ldi temp, 5
00009d bf03                      out TCCR0,temp
                                 
                                 ;TIMER1 Settings
                                 ;ldi temp, 0				; Выключаем подсчёт тактов, а включим только при необходимости
                                 ;out TCCR1B, temp
                                 
                                 ;TIMER2 Settings
00009e e000                      ldi temp, 0				; Выключаем подсчёт тактов, а включим только при необходимости
00009f bd05                      out TCCR2, temp
                                 
                                 ;ldi temp, 01			;Задаём TIMSK для всех таймеров
0000a0 e401                      ldi temp,(1<<TOIE2)|(1<<TOIE0);|(1<<TOIE1)
0000a1 bf09                      out TIMSK, temp
                                 
0000a2 e308                      ldi temp, 0b00111000
0000a3 bb04                      out ddrc, temp
                                 
0000a4 e001                      ldi temp, 0b00000001
0000a5 bb07                      out ddrb, temp
0000a6 9aad                      sbi	PORTC,5
                                 
                                 ;ldi temp, 0b0010000
                                 ;out ddrd, temp
                                 /*
                                 ldi XH,high(DO_data)
                                 ldi XL,low(DO_data)
                                 st X+, temp
                                 out PORTC, temp
                                 */
0000a7 e80e                      ldi temp, 0b10001110
0000a8 bb01                      out ddrd, temp
0000a9 2f30                      mov msg, temp
                                 
                                 
0000aa d474                      rcall USART_Init
                                 ;ldi temp, 0x01
                                 ;sts devise_address, temp
                                 /*
                                 ldi		temp,	0xff
                                 sts		eeprom_data,	temp
                                 ldi		sys,	0x00
                                 sts		eeprom_address,	sys
                                 EEWrite sys, temp
                                 ldi		sys,	0x01
                                 sts		eeprom_address,	sys
                                 EEWrite sys, temp
                                 ldi		sys,	0x02
                                 sts		eeprom_address,	sys
                                 EEWrite sys, temp
                                 ;*/
                                 
                                 /*
                                 ldi		r18,	0xff
                                 ldi		temp,	0x06
                                 loop_e:
                                 	dec		temp
                                 	out 	EEARL,	temp
                                 	rcall	EEWrite_func
                                 	brne	loop_e
                                 ;*/
                                 ; Чтение адреса
0000ab e0b2                      ldi XH,high(AO_data)
0000ac e1a3                      ldi XL,low(AO_data)
                                 
0000ad 99e1
0000ae cffe
0000af 930f
0000b0 b70f
0000b1 930f
0000b2 e000
0000b3 bf0f
0000b4 938f
0000b5 e080
0000b6 bb8f
0000b7 e080
0000b8 bb8e
0000b9 9ae0
0000ba b38d
0000bb 9380 014a
0000bd 0000
0000be 0000
0000bf 0000
0000c0 0000
0000c1 918f
0000c2 910f
0000c3 bf0f
0000c4 910f                      EERead 0x00
0000c5 99e0                      sbic	EECR,EERE		; Ждем готовности памяти к записи. Крутимся в цикле
0000c6 cffe                      rjmp	PC-1
0000c7 9100 014a                 lds temp, eeprom_data
0000c9 3f0f                      cpi temp, 0xff
0000ca f511                      brne	AdrRead_end
0000cb e001                      	ldi temp, 0x01
0000cc e010                      	ldi sys, 0x00
0000cd 9310 014b                 	sts	eeprom_address,	sys
0000cf 9300 014a                 	sts	eeprom_data,	temp
0000d1 99e1
0000d2 cffe
0000d3 930f
0000d4 b70f
0000d5 930f
0000d6 e000
0000d7 bf0f
0000d8 937f
0000d9 938f
0000da e080
0000db bb8f
0000dc 9180 014b
0000de bb8e
0000df 9180 014a
0000e1 bb8d
0000e2 9ae2
0000e3 9ae1
0000e4 0000
0000e5 0000
0000e6 0000
0000e7 0000
0000e8 918f
0000e9 917f
0000ea 910f
0000eb bf0f
0000ec 910f                      	EEWrite; sys, temp
                                 AdrRead_end:
0000ed e010                      ldi	r17,0x00
0000ee 931d                      st	X+,	r17
0000ef 9300 0214                 sts	devise_address,	temp
0000f1 9300 014e                 sts prev_devise_address, temp
                                 
                                 
                                 ;Чтение минимального порога температуры
0000f3 99e1
0000f4 cffe
0000f5 930f
0000f6 b70f
0000f7 930f
0000f8 e000
0000f9 bf0f
0000fa 938f
0000fb e080
0000fc bb8f
0000fd e081
0000fe bb8e
0000ff 9ae0
000100 b38d
000101 9380 014a
000103 0000
000104 0000
000105 0000
000106 0000
000107 918f
000108 910f
000109 bf0f
00010a 910f                      EERead 0x01
00010b 9110 014a                 lds		r17,	eeprom_data
00010d 3f1f                      cpi		r17,	0xff
00010e f0d9                      	breq	TemMinRead_CLRD
00010f 99e1
000110 cffe
000111 930f
000112 b70f
000113 930f
000114 e000
000115 bf0f
000116 938f
000117 e080
000118 bb8f
000119 e082
00011a bb8e
00011b 9ae0
00011c b38d
00011d 9380 014a
00011f 0000
000120 0000
000121 0000
000122 0000
000123 918f
000124 910f
000125 bf0f
000126 910f                      EERead 0x02
000127 9100 014a                 lds		r16,	eeprom_data
000129 c010                      rjmp	TemMinRead_End
                                 
                                 	TemMinRead_CLRD:	;Если память пуста, то записываем +25
                                 	;sts		eeprom_address,	r18
                                 	;sts		eeprom_data,	r17
00012a e000                      	ldi		r16,	0x00
00012b bb0f                      	out 	EEARH,	r16
00012c e001                      	ldi		r16,	0x01
00012d bb0e                      	out 	EEARL,	r16
00012e e013                      	ldi		r17,	0b00000011	
00012f 9310 0217                 	sts		temperature_min,	r17	
000131 2f21                      	mov		r18,	r17
000132 d3da                      		rcall	EEWrite_func
                                 	;sts		eeprom_address,	r18
                                 	;sts		eeprom_data,	r17
                                 	;ldi		r16,	0b10100010
                                 	;ldi		r18,	0x02
000133 e002                      	ldi		r16,	0x02
000134 bb0e                      	out 	EEARL,	r16
000135 ea02                      	ldi		r16,	0b10100010
000136 9310 0218                 	sts		temperature_min+1,	r17	
000138 2f20                      	mov		r18,	r16
000139 d3d3                      		rcall	EEWrite_func
                                 
                                 TemMinRead_End:
00013a 9310 0217                 sts	temperature_min,	r17
00013c 9310 014f                 sts	prev_temperature_min,	r17
00013e 9300 0218                 sts	temperature_min+1,	r16
000140 9300 0150                 sts	prev_temperature_min+1,	r16
                                 
                                 ;Чтение максимального порога температуры
000142 99e1
000143 cffe
000144 930f
000145 b70f
000146 930f
000147 e000
000148 bf0f
000149 938f
00014a e080
00014b bb8f
00014c e083
00014d bb8e
00014e 9ae0
00014f b38d
000150 9380 014a
000152 0000
000153 0000
000154 0000
000155 0000
000156 918f
000157 910f
000158 bf0f
000159 910f                      EERead 0x03
00015a 9110 014a                 lds		r17,	eeprom_data
00015c 3f1f                      cpi		r17,	0xff
00015d f0d9                      	breq	TemMaxRead_CLRD
00015e 99e1
00015f cffe
000160 930f
000161 b70f
000162 930f
000163 e000
000164 bf0f
000165 938f
000166 e080
000167 bb8f
000168 e084
000169 bb8e
00016a 9ae0
00016b b38d
00016c 9380 014a
00016e 0000
00016f 0000
000170 0000
000171 0000
000172 918f
000173 910f
000174 bf0f
000175 910f                      EERead 0x04
000176 9100 014a                 lds		r16,	eeprom_data			
000178 c010                      rjmp	TemMaxRead_End
                                 	TemMaxRead_CLRD:	;Если память пуста, то записываем +60
000179 e000                      	ldi		r16,	0x00
00017a bb0f                      	out 	EEARH,	r16
00017b e003                      	ldi		r16,	0x03
00017c bb0e                      	out 	EEARL,	r16
00017d e012                      	ldi		r17,	0b00000010
00017e 9310 0215                 	sts		temperature_max,	r17	
000180 2f21                      	mov		r18,	r17
000181 d38b                      		rcall	EEWrite_func
000182 e004                      	ldi		r16,	0x04
000183 bb0e                      	out 	EEARL,	r16
000184 ed0a                      	ldi		r16,	0b11011010
000185 9300 0216                 	sts		temperature_max+1,	r16
000187 2f20                      	mov		r18,	r16
000188 d384                      		rcall	EEWrite_func
                                 	/*
                                 	ldi		r17,	0b00000010
                                 	ldi		r18,	0x03
                                 	sts		eeprom_address,	r18
                                 	sts		eeprom_data,	r17
                                 	EEWrite
                                 	ldi		r16,	0b11011010
                                 	ldi		r18,	0x04
                                 	sts		eeprom_address,	r18
                                 	sts		eeprom_data,	r17
                                 	EEWrite
                                 	*/
                                 TemMaxRead_End:
000189 9310 0215                 sts	temperature_max,	r17
00018b 9310 0151                 sts	prev_temperature_max,	r17
00018d 9300 0216                 sts	temperature_max+1,	r16
00018f 9300 0152                 sts	prev_temperature_max+1,	r16
                                 /*
                                 EERead 0x01
                                 lds temp, eeprom_data
                                 cpi temp, 0xff
                                 brne TemMinRead_end
                                 	ldi temp, 0b11100011 ;Нижнее ограничение диапазона температуры  +30
                                 	ldi sys, 0x01
                                 	sts	eeprom_address,	sys
                                 	sts	eeprom_data,	temp
                                 	EEWrite; sys, temp
                                 TemMinRead_end:
                                 ldi	r17,0x00
                                 st	X+,	r17
                                 st	X+,	temp
                                 sts temperature_min, temp
                                 
                                 ;Чтение максимального порога температуры
                                 EERead 0x02
                                 lds temp, eeprom_data
                                 cpi temp, 0xff
                                 brne TemMaxRead_end
                                 	ldi temp, 0b10110110 ; Верхнее ограничение диапазона температуры  +60
                                 	ldi sys, 0x02
                                 	sts	eeprom_address,	sys
                                 	sts	eeprom_data,	temp
                                 	EEWrite; sys, temp
                                 TemMaxRead_end:
                                 ldi	r17,0x00
                                 st	X+,	r17
                                 st	X+,	temp
                                 sts temperature_max, temp
                                 */
000191 99e1                      sbic	EECR,EEWE		; Ждем готовности памяти к записи. Крутимся в цикле
000192 cffe                      rjmp	PC-1
                                 
                                 /*
                                 ; Установление min и max для температуры
                                 ldi temp, 0b11100011 ;Нижнее ограничение диапазона температуры  +30
                                 sts temperature_min, temp
                                 ldi temp, 0b10110110 ; Верхнее ограничение диапазона температуры  +60
                                 sts temperature_max, temp*/
                                 
000193 e000                      ldi temp, 0x00
000194 9300 0120                 sts in_offset, temp
000196 9300 0122                 sts in_count, temp
000198 e0e0                      ldi ZL, low(in_data)
000199 e0f1                      ldi ZH, high(in_data)
                                 
00019a e2c3                      ldi YL, low(out_data)
00019b e0d1                      ldi YH, high(out_data)
                                 
                                 /*
                                 ldi XL, low(AO_data)
                                 ldi XH, high(AO_data)
                                 ld	temp,	X+
                                 ldi	temp,	0x03
                                 st	X+,		temp
                                 */
00019c 9aad                      sbi	PORTC,	5
00019d 9478                      sei
                                 /*
                                 ldi ZL,low(in_data)	
                                 ldi ZH,high(in_data)
                                 ldi temp, 0x01
                                 st Z+,temp
                                 ldi temp, 0x06
                                 st Z+,temp
                                 ldi temp, 0x00
                                 st Z+,temp
                                 ldi temp, 0x01
                                 st Z+,temp
                                 ldi temp, 0x00
                                 st Z+,temp
                                 ldi temp, 0x10
                                 st Z+,temp
                                 ldi temp, 6
                                 sts in_offset, temp
                                 ;*/
                                 
                                 ;----------------------------- MAIN ---------------------------;
                                 main:
00019e ec0f                      	ldi temp, 0b11001111
00019f b906                      	out ADCSRA, temp
                                 
                                 	/*
                                 	ldi XL,low(DI_data)			; Чтение значений из пямяти дискретных выводов для индикации
                                 	ldi XH,high(DI_data)
                                 	ld temp, X
                                 
                                 	sbr temp, 0x20
                                 	out PORTC,temp
                                 	*/
0001a0 9100 0193                 	lds		temp,	DI_Data
0001a2 9110 0015                 	lds		sys,	PORTC
0001a4 3001                      	cpi		temp,	0x01
0001a5 f411                      	brne	PC+3
0001a6 9aab                      		sbi		PORTC,	3
0001a7 c001                      		rjmp	PC+2
0001a8 98ab                      	cbi		PORTC,	3
0001a9 3002                      	cpi		temp,	0x02
0001aa f411                      	brne	PC+3
0001ab 9aac                      		sbi		PORTC,	4
0001ac c001                      		rjmp	PC+2
0001ad 98ac                      	cbi		PORTC,	4
                                 	;sbi PORTC,5
0001ae 9892                      	cbi PORTD,2
                                 	;ld sys, X+
                                 	;ldi XL,low(DI_data)			; Опрос дискретных входов и занесение значений в память DI
                                 	;ldi XH,high(DI_data)
                                 	;in temp, PORTB
                                 	;st X+,temp
                                 	
                                 	;ldi temp, 0x20
                                 	;sts temperature, temp
                                 	;;;;;;;;;;
                                 
0001af d378                      	rcall Temperature_Read
                                 
                                 	;;;;;;;;;;
0001b0 94f8                      	cli
                                 	;ldi XL,low(AO_data)			; Чтение значений из пямяти аналоговых выводов для изменения еепром
                                 	;ldi XH,high(AO_data)
                                 	;lds	temp,	devise_address
                                 	;ld	sys,	X+
                                 	;ld	sys,	X+
0001b1 0000                      	nop
0001b2 0000                      	nop
                                 	/*cpi	sys,	0x00	
                                 	brne PC+4
                                 		st	-X,		temp
                                 		ld	sys,	X+
                                 		rjmp	PC+3*/
                                 	;rjmp	main_check_tempmin
0001b3 9100 0214                 	lds	temp,	devise_address
0001b5 9110 014e                 	lds	sys,	prev_devise_address
0001b7 1701                      	cp	temp,	sys
0001b8 f041                      	breq	main_check_tempmin
0001b9 e010                      		ldi		sys,	0x00
0001ba bb1f                      		out 	EEARH,	sys
0001bb e010                      		ldi		sys,	0x00
0001bc bb1e                      		out 	EEARL,	sys
0001bd 2f20                      		mov		r18,	temp
0001be d34e                      			rcall	EEWrite_func
0001bf 9300 014e                 		sts		prev_devise_address,	temp
                                 		/*
                                 		sbi		PORTC,	5
                                 		sts		prev_devise_address,	sys
                                 		ldi		temp,	0x01
                                 		sts		eeprom_flag,	temp
                                 		sts		eeprom_data, sys
                                 		ldi		temp,	0x00
                                 		sts		eeprom_address, temp
                                 		rjmp	main_AO_check_end
                                 		*/
                                 	main_check_tempmin:
0001c1 9110 014f                 	lds		r17,	prev_temperature_min
0001c3 9100 0150                 	lds		r16,	prev_temperature_min+1
0001c5 91b0 0217                 	lds		XH,		temperature_min
0001c7 91a0 0218                 	lds		XL,		temperature_min+1
0001c9 171b                      	cp		r17,	XH
0001ca f419                      		brne	main_check_tempmin_chgd
0001cb 170a                      	cp		r16,	XL
0001cc f409                      		brne	main_check_tempmin_chgd
0001cd c00e                      	rjmp	main_check_tempmax
                                 		main_check_tempmin_chgd:
0001ce e000                      		ldi		r16,	0x00
0001cf bb0f                      		out 	EEARH,	r16
0001d0 e001                      		ldi		r16,	0x01
0001d1 bb0e                      		out 	EEARL,	r16
0001d2 2f2b                      		mov		r18,	XH
0001d3 d339                      			rcall	EEWrite_func
0001d4 e002                      		ldi		r16,	0x02
0001d5 bb0e                      		out 	EEARL,	r16
0001d6 2f2a                      		mov		r18,	XL
0001d7 d335                      			rcall	EEWrite_func
0001d8 93b0 014f                 		sts		prev_temperature_min,	XH
0001da 93a0 0150                 		sts		prev_temperature_min+1,	XL
                                 	main_check_tempmax:
0001dc 9110 0151                 	lds		r17,	prev_temperature_max
0001de 9100 0152                 	lds		r16,	prev_temperature_max+1
0001e0 91b0 0215                 	lds		XH,		temperature_max
0001e2 91a0 0216                 	lds		XL,		temperature_max+1
0001e4 171b                      	cp		r17,	XH
0001e5 f419                      		brne	main_check_tempmax_chgd
0001e6 170a                      	cp		r16,	XL
0001e7 f409                      		brne	main_check_tempmax_chgd
0001e8 c00e                      	rjmp	main_AO_check_end
                                 		main_check_tempmax_chgd:
0001e9 e000                      		ldi		r16,	0x00
0001ea bb0f                      		out 	EEARH,	r16
0001eb e003                      		ldi		r16,	0x03
0001ec bb0e                      		out 	EEARL,	r16
0001ed 2f2b                      		mov		r18,	XH
0001ee d31e                      			rcall	EEWrite_func
0001ef e004                      		ldi		r16,	0x04
0001f0 bb0e                      		out 	EEARL,	r16
0001f1 2f2a                      		mov		r18,	XL
0001f2 d31a                      			rcall	EEWrite_func
0001f3 93b0 0151                 		sts		prev_temperature_max,	XH
0001f5 93a0 0152                 		sts		prev_temperature_max+1,	XL
                                 	/*
                                 	cp	temp,	sys
                                 	rjmp	main_check_tempmax
                                 		sts		temperature_min,	sys
                                 		ldi		temp,	0x01
                                 		sts		eeprom_flag,	temp
                                 		sts		eeprom_data, sys
                                 		sts		eeprom_address, temp
                                 		rjmp	main_AO_check_end
                                 	main_check_tempmax:
                                 	lds	temp,	temperature_max
                                 	ld	sys,	X+
                                 	ld	sys,	X+
                                 	cp	temp,	sys
                                 	breq	main_AO_check_end
                                 		sts		temperature_max,	sys
                                 		ldi		temp,	0x01
                                 		sts		eeprom_flag,	temp
                                 		sts		eeprom_data, sys
                                 		ldi		temp,	0x02
                                 		sts		eeprom_address, temp
                                 	*/
                                 	main_AO_check_end:
0001f7 9478                      	sei
                                 	/*
                                 	lds temp, eeprom_flag
                                 	cpi temp, 0x01
                                 	brne EEPROM_write_end
                                 		;cli
                                 		;lds temp, eeprom_data
                                 		;lds sys, eeprom_address
                                 		EEWrite sys, temp
                                 		cli
                                 		clr temp
                                 		;sts eeprom_data, temp
                                 		;sts eeprom_address, temp
                                 		sts eeprom_flag, temp
                                 		sei
                                 	EEPROM_write_end:
                                 	*/
0001f8 9100 0120                 	lds temp, in_offset				; ждать появления первого байта
0001fa 2300                      	and temp,temp
0001fb f021                      		breq Main_end
0001fc 9a97                      	sbi	PORTD,7
                                 	; Переход на приём/передачу по modbus
                                 	;ldi temp, 0b00001111			; выключаем АЦП
0001fd e00f                      	ldi temp, 0b00001111
0001fe b906                      	out ADCSRA, temp
0001ff c001                      	rjmp MODBUS_Communication
                                 	Main_end:
000200 cf9d                      rjmp main
                                 
                                 ;--------------------------- КОНЕЦ MAIN'А---------------------;
                                 
                                 ;-------------------- ПРИЁМ/ПЕРЕДАЧА ПО MODBUS----------------;
                                 MODBUS_Communication:
                                 	;/*
000201 e0f1                      	ldi ZH, high(in_data)
000202 e0e0                      	ldi ZL, low(in_data)
000203 9101                      	ld	temp,	Z+
                                 	;ld temp, -Z					; проверка адреса устройства
                                 	;st Z+, temp
000204 3000                      	cpi	temp,	0
000205 f029                      	breq	wait_end
                                 
000206 9110 0214                 	lds sys, devise_address
000208 1701                      	cp	temp,	sys
000209 f009                      	breq	wait_end
00020a c2e4                      	rjmp	Modbus_end
                                 	;cpse temp, sys
                                 	;rjmp Modbus_end
                                 
                                   wait_end:
00020b 9100 0121                 	lds temp, in_flag			; ждать завершения принятого пакета
00020d 2300                      	and temp,temp
00020e f7e1                      	brne wait_end
                                 	
00020f 94f8                      	cli
000210 9897                      	cbi	PORTD,7
000211 e0f1                      	ldi ZH, high(in_data)
000212 e0e0                      	ldi ZL, low(in_data)
000213 9100 0120                 	lds temp,in_offset
                                   calc_crc:
000215 9131                      	ld msg, Z+
000216 930f
000217 931f
000218 2f03
000219 e018
00021a 2760
00021b 9556
00021c 9567
00021d f420
00021e ea00
00021f 2750
000220 e001
000221 2760
000222 951a
000223 f7b9
000224 911f
000225 910f                      	crc16 msg
000226 950a                      	dec temp
000227 f769                      	brne calc_crc
                                 
000228 e000                      	ldi temp, 0x00				; Проверка CRC
000229 1350                      	cpse CRCHi, temp
00022a c2c4                      	rjmp Modbus_end
00022b 1356                      	cpse CRCHi,CRCLo
00022c c2c2                      	rjmp Modbus_end
                                 	;*/
                                   end_receive:
00022d 9100 0120                 	lds temp, in_offset			; сформировать число принятых байтов
00022f 950a                      	dec temp
000230 950a                      	dec temp
000231 9300 0122                 	sts in_count,temp
                                 
000233 e0f1                      	ldi ZH, high(in_data)	
000234 e0e0                      	ldi ZL, low(in_data)
000235 e0d1                      	ldi YH, high(out_data)
000236 e2c3                      	ldi YL, low(out_data)
                                 ;----------Запись адреса в буфер и определение modbus функции-------;
000237 9131                      	ld msg,Z+
000238 9339                      	st Y+, msg
000239 9121                      	ld function, Z+
00023a e042                      	ldi lenght, 2
                                 
00023b 930f
00023c b70f
00023d 930f
00023e 931f
00023f 933f
000240 935f
000241 936f
000242 3021
000243 f079
000244 3022
000245 f071
000246 3023
000247 f069
000248 3024
000249 f061
00024a 3025
00024b f059
00024c 3026
00024d f059
00024e 302f
00024f f041
000250 3120
000251 f041
000252 f441
000253 c008
000254 c055
000255 c0a2
000256 c0d5
000257 c108
000258 c163
000259 c13f
00025a c1e9
00025b c220
00025c 91b1
00025d 91a1
00025e 30b0
00025f f479
000260 30a0
000261 f068
000262 30a4
000263 f458
000264 9101
000265 3000
000266 f449
000267 9101
000268 3001
000269 f030
00026a e31e
00026b 1b1a
00026c 1701
00026d f410
00026e c002
00026f c21a
000270 c227
000271 93b0 0145
000273 93a0 0146
000275 9300 0149
000277 9329
000278 e010
000279 ef3f
00027a 9513
00027b 3008
00027c f018
00027d 5008
00027e f009
00027f f7d1
000280 9319
000281 9543
000282 2f31
000283 9100 0146
000285 e010
000286 9513
000287 3008
000288 f018
000289 5008
00028a f009
00028b f7d1
00028c e0b1
00028d e5a3
00028e 915d
00028f 951a
000290 f7e9
000291 916d
000292 3000
000293 f021
000294 9566
000295 9557
000296 950a
000297 f7e1
000298 910e
000299 e000
00029a 9110 0149
00029c 9408
00029d 1f00
00029e 951a
00029f f7e1
0002a0 2350
0002a1 9359
0002a2 9543
0002a3 2f56
0002a4 916d
0002a5 953a
0002a6 f7c9
0002a7 9340 0143
0002a9 c20a
0002aa 91b1
0002ab 91a1
0002ac 30b0
0002ad f479
0002ae 30a0
0002af f068
0002b0 34a0
0002b1 f458
0002b2 9101
0002b3 3000
0002b4 f449
0002b5 9101
0002b6 3001
0002b7 f030
0002b8 e31e
0002b9 1b1a
0002ba 1701
0002bb f410
0002bc c002
0002bd c1cc
0002be c1d9
0002bf 93b0 0145
0002c1 93a0 0146
0002c3 9300 0149
0002c5 9329
0002c6 e010
0002c7 ef3f
0002c8 9513
0002c9 3008
0002ca f018
0002cb 5008
0002cc f009
0002cd f7d1
0002ce 9319
0002cf 9543
0002d0 2f31
0002d1 9100 0146
0002d3 e010
0002d4 9513
0002d5 3008
0002d6 f018
0002d7 5008
0002d8 f009
0002d9 f7d1
0002da e0b1
0002db e9a3
0002dc 915d
0002dd 951a
0002de f7e9
0002df 916d
0002e0 3000
0002e1 f021
0002e2 9566
0002e3 9557
0002e4 950a
0002e5 f7e1
0002e6 910e
0002e7 e000
0002e8 9110 0149
0002ea 9408
0002eb 1f00
0002ec 951a
0002ed f7e1
0002ee 2350
0002ef 9359
0002f0 9543
0002f1 2f56
0002f2 916d
0002f3 953a
0002f4 f7c9
0002f5 9340 0143
0002f7 c1bc
0002f8 91b1
0002f9 91a1
0002fa 30b0
0002fb f479
0002fc 30a0
0002fd f068
0002fe 32a0
0002ff f458
000300 9111
000301 9101
000302 3010
000303 f441
000304 3001
000305 f030
000306 2f3a
000307 0f30
000308 3231
000309 f410
00030a c002
00030b c17e
00030c c17d
00030d 93b0 0145
00030f 93a0 0146
000311 9300 0149
000313 9329
000314 0f00
000315 9309
000316 9100 0149
000318 9543
000319 e0b2
00031a e1a3
00031b 9130 0146
00031d 3030
00031e f021
00031f 911d
000320 911d
000321 953a
000322 f7e1
000323 911d
000324 9319
000325 9543
000326 911d
000327 9319
000328 9543
000329 950a
00032a f7c1
00032b c188
00032c 91b1
00032d 91a1
00032e 30b0
00032f f479
000330 30a0
000331 f068
000332 32a0
000333 f458
000334 9111
000335 9101
000336 3010
000337 f441
000338 3001
000339 f030
00033a 2f3a
00033b 0f30
00033c 3231
00033d f410
00033e c002
00033f c14a
000340 c149
000341 93b0 0145
000343 93a0 0146
000345 9300 0149
000347 9329
000348 0f00
000349 9309
00034a 9100 0149
00034c 9543
00034d e0b1
00034e eda3
00034f 9130 0146
000351 3030
000352 f281
000353 911d
000354 911d
000355 953a
000356 f7e1
000357 911d
000358 9319
000359 9543
00035a 911d
00035b 9319
00035c 9543
00035d 950a
00035e f7c1
00035f c154
000360 91b1
000361 91a1
000362 30b0
000363 f599
000364 30a0
000365 f188
000366 30a6
000367 f578
000368 9111
000369 9101
00036a 30a5
00036b f141
00036c 3000
00036d f551
00036e 3010
00036f f019
000370 3f1f
000371 f009
000372 c025
000373 9329
000374 93b9
000375 9543
000376 93a9
000377 9543
000378 9319
000379 9543
00037a 9309
00037b 9543
00037c e061
00037d 2f5a
00037e 3050
00037f f019
000380 0f66
000381 955a
000382 f7e9
000383 e0b1
000384 e5a3
000385 3f1f
000386 f431
000387 910d
000388 2b06
000389 930e
00038a 9340 0143
00038c c127
00038d 9560
00038e 910d
00038f 2306
000390 930e
000391 9340 0143
000393 c120
000394 3f1f
000395 f411
000396 ccf1
000397 c0f2
000398 c0ff
000399 91b1
00039a 91a1
00039b 30b0
00039c f439
00039d 30a0
00039e f028
00039f 32a0
0003a0 f418
0003a1 9111
0003a2 9101
0003a3 c002
0003a4 c0e5
0003a5 c0f2
0003a6 9329
0003a7 93b9
0003a8 9543
0003a9 93a9
0003aa 9543
0003ab 9319
0003ac 9543
0003ad 9309
0003ae 9543
0003af 2f3a
0003b0 e0b2
0003b1 e1a3
0003b2 c000
0003b3 3030
0003b4 f021
0003b5 915d
0003b6 915d
0003b7 953a
0003b8 f7e1
0003b9 931d
0003ba 930d
0003bb c0f8
0003bc 91b1
0003bd 91a1
0003be 30b0
0003bf f549
0003c0 30a0
0003c1 f138
0003c2 30a5
0003c3 f528
0003c4 93b0 0145
0003c6 93a0 0146
0003c8 9101
0003c9 3000
0003ca f4f9
0003cb 9300 0147
0003cd 9101
0003ce 3001
0003cf f0d0
0003d0 e016
0003d1 1b1a
0003d2 1701
0003d3 f4b0
0003d4 9300 0148
0003d6 9111
0003d7 9310 0149
0003d9 3010
0003da f421
0003db 9513
0003dc 9310 0149
0003de c00f
0003df e038
0003e0 9f31
0003e1 1730
0003e2 f040
0003e3 5038
0003e4 1730
0003e5 f428
0003e6 9310 0149
0003e8 c005
0003e9 c0a0
0003ea c0ad
0003eb c0ba
0003ec e0b1
0003ed e5a3
0003ee 9100 0146
0003f0 9110 0148
0003f2 9170 0149
0003f4 ef3f
0003f5 9131
0003f6 3018
0003f7 f550
0003f8 915d
0003f9 3000
0003fa f079
0003fb 9556
0003fc 9567
0003fd 950a
0003fe f7e1
0003ff 9100 0146
000401 0f66
000402 1f33
000403 950a
000404 f7e1
000405 9100 0146
000407 0f55
000408 950a
000409 f7e9
00040a 9100 0146
00040c 0f01
00040d e018
00040e 1b10
00040f 2f01
000410 0f33
000411 950a
000412 f7e9
000413 2f01
000414 e060
000415 0f55
000416 1f66
000417 950a
000418 f7e1
000419 2f01
00041a 9566
00041b 9537
00041c 950a
00041d f7e1
00041e e0b1
00041f e5a3
000420 933c
000421 c006
000422 e0b1
000423 e5a3
000424 916d
000425 2363
000426 936e
000427 5018
000428 911f
000429 9110 0149
00042b 951a
00042c 9310 0149
00042e 931f
00042f f621
000430 9329
000431 9100 0145
000433 9309
000434 9543
000435 9100 0146
000437 9309
000438 9543
000439 9100 0147
00043b 9309
00043c 9543
00043d 9100 0148
00043f 9309
000440 9543
000441 9340 0143
000443 c070
000444 91b1
000445 91a1
000446 30b0
000447 f4a1
000448 30a0
000449 f090
00044a 32a0
00044b f480
00044c 9111
00044d 9101
00044e 3010
00044f f469
000450 3001
000451 f058
000452 2f3a
000453 0f30
000454 3231
000455 f438
000456 9131
000457 2f50
000458 0f50
000459 1753
00045a f411
00045b c002
00045c c02d
00045d c02c
00045e 93b0 0145
000460 93a0 0146
000462 9330 0149
000464 9329
000465 93b9
000466 9543
000467 93a9
000468 9543
000469 9319
00046a 9543
00046b 9309
00046c 9543
00046d e0b2
00046e e1a3
00046f 9150 0146
000471 0f55
000472 3050
000473 f019
000474 916d
000475 955a
000476 f7e9
000477 9161
000478 936d
000479 953a
00047a f7e1
00047b c038
00047c 933f
00047d e830
00047e 0f32
00047f 9339
000480 e031
000481 9339
000482 9130 0143
000484 9533
000485 9330 0143
000487 9543
000488 913f
000489 c02a
00048a 933f
00048b e830
00048c 0f32
00048d 9339
00048e e032
00048f 9339
000490 9130 0143
000492 9533
000493 9330 0143
000495 9543
000496 913f
000497 c01c
000498 933f
000499 e830
00049a 0f32
00049b 9339
00049c e033
00049d 9339
00049e 9130 0143
0004a0 9533
0004a1 9330 0143
0004a3 9543
0004a4 913f
0004a5 c00e
0004a6 933f
0004a7 e830
0004a8 0f32
0004a9 9339
0004aa e033
0004ab 9339
0004ac 9130 0143
0004ae 9533
0004af 9330 0143
0004b1 9543
0004b2 913f
0004b3 c000
0004b4 916f
0004b5 915f
0004b6 913f
0004b7 911f
0004b8 910f
0004b9 bf0f
0004ba 910f                      	Read_Func function
                                 ;----------Начало передачи-----------;
                                 	;
                                 	;cbi PORTD,2
                                 	;ldi XH,high(DO_data)			 ; Выключаем светодиод при передаче
                                 	;ldi XL,low(DO_data)
                                 	;ld temp, X+
                                 	;sbr temp, $10
                                 	;st -X, temp
0004bb 0000                      	nop
0004bc 0000                      	nop
0004bd 0000                      	nop
0004be 9a92                      	sbi PORTD,2
                                 
0004bf 9ac0                      	sbi	PORTB,0
                                 
0004c0 e0d1                      	ldi YH, high(out_data)
0004c1 e2c3                      	ldi YL, low(out_data)
                                 
0004c2 9340 0143                 	sts out_offset, lenght
0004c4 ef6f                      	ldi CRCLo, 0xff
0004c5 ef5f                      	ldi CRCHi, 0xff
0004c6 9100 0143                 	lds temp, out_offset
                                 	main_loop:					; Передача пакета
0004c8 9139                      	ld msg, Y+
0004c9 930f
0004ca 931f
0004cb 2f03
0004cc e018
0004cd 2760
0004ce 9556
0004cf 9567
0004d0 f420
0004d1 ea00
0004d2 2750
0004d3 e001
0004d4 2760
0004d5 951a
0004d6 f7b9
0004d7 911f
0004d8 910f                      	crc16 msg
0004d9 930f
0004da b10b
0004db ff05
0004dc cffd
0004dd b93c
0004de 910f                      	USART_Trancieve msg
0004df 950a                      	dec temp
0004e0 f739                      	brne main_loop
0004e1 2f36                      	mov msg, CRCLo
0004e2 930f
0004e3 b10b
0004e4 ff05
0004e5 cffd
0004e6 b93c
0004e7 910f                      	USART_Trancieve msg		; Добавление CRC в передаваемый пакет
0004e8 2f35                      	mov msg, CRCHi
0004e9 930f
0004ea b10b
0004eb ff05
0004ec cffd
0004ed b93c
0004ee 910f                      	USART_Trancieve msg
                                 	
                                 	;ldi temp, 0x07				; Включение таймера и прерывания по его переполнению 5*256 тактов
                                 	;sts TCCR2, temp
                                 	;ldi temp, 5
                                 	;sts out_flag, temp
                                 
                                 	Modbus_end:					; Сбрасываем память для приёма следующей посылки
0004ef 9897                      	cbi	PORTD,7
0004f0 e000                      	ldi temp,0x00
0004f1 9300 0122                 	sts in_count, temp	
0004f3 9300 0120                 	sts in_offset, temp
0004f5 e2c3                      	ldi YL, low(out_data)
0004f6 e0d1                          ldi YH, high(out_data)
0004f7 e0e0                      	ldi ZL, low(in_data)
0004f8 e0f1                          ldi ZH, high(in_data)
0004f9 ef6f                      	ldi CRCLo, 0xff
0004fa ef5f                      	ldi CRCHi, 0xff
                                 
0004fb efaf                      	ldi XL, low(0xffff)
0004fc efbf                          ldi XH, high(0xffff)
0004fd 9711                      	sbiw  XH:XL,1  
0004fe f7f1                      		brne	PC-1
                                 	;/*
0004ff efaf                      	ldi XL, low(0xffff)
000500 efbf                          ldi XH, high(0xffff)
000501 9711                      	sbiw  XH:XL,1
000502 efaf                      	ldi XL, low(0xffff)
000503 efbf                          ldi XH, high(0xffff)
000504 9711                      	sbiw  XH:XL,1  
000505 f7f1                      		brne	PC-1
000506 efaf                      	ldi XL, low(0xffff)
000507 efbf                          ldi XH, high(0xffff)
000508 9711                      	sbiw  XH:XL,1
000509 f7f1                      		brne	PC-1;*/
00050a 98c0                      	cbi	PORTB,0
00050b 9478                      	sei
00050c cc91                      rjmp main
                                 
                                 EEWrite_func:	
00050d 99e1                      	SBIC	EECR,	EEWE		
00050e cffe                      	RJMP	EEWrite_func
                                 		
00050f bb2d                      	OUT 	EEDR,	r18
                                  
000510 9ae2                      	SBI 	EECR,	EEMWE
000511 9ae1                      	SBI 	EECR,	EEWE
                                 
000512 9508                      RET 
                                 
                                 EERead_func:
                                 
000513 9508                      ret
                                 
                                 ADC_Conv_Complete:					; Прерывание по окончанию преобразования
                                 	;cli
000514 930f                      	push	r16
000515 931f                      	push	r17
                                 	;in r16, SREG
                                 	;push r16
                                 	;lds razr1,ADCL
000516 b104                      	in		r16,	ADCL
000517 b115                      	in		r17,	ADCH
000518 9310 01d5                 	sts		temperature, r17
00051a 9300 01d6                 	sts		temperature+1, r16
                                 	;sts tmperature_data
                                 
                                 Vix:
                                 	/*ldi temp, 0b01100000
                                 	out ADMUX, temp
                                 	ldi temp, 0b11011100
                                 	out ADCSRA, temp*/
00051c 911f                      	pop		r17
00051d 910f                      	pop		r16
                                 	;out SREG, r16
                                 	;pop r16
                                 	;sei
00051e 9518                      reti
                                 
                                 USART_Init:          ; Настройка USART
00051f e000                      	ldi temp, high(UBRR_Value)
000520 bd00                      	out UBRRH, temp
000521 e100                      	ldi temp, low(UBRR_Value)
000522 b909                      	out UBRRL, temp
                                 
                                 	;ldi temp, (1<<UDRE)
                                 	;out UCSRA, temp
000523 e908                      	ldi temp, (1<<TXEN)|(1<<RXEN)|(1<<RXCIE);|(1<<TXCIE0)||(1<< UDRIE0)
000524 b90a                      	out UCSRB, temp
000525 e80e                      	ldi temp,(1<<URSEL)|(3<<UCSZ0)|(1<< USBS)|(0<<UPM1)|(0<<UPM0)
000526 bd00                      	out UCSRC, temp
                                 
000527 9508                      ret
                                 
                                 Temperature_Read:		; Запись значений с термистора в оперативную память
000528 930f                      	push r16
                                 	;sei
000529 b70f
00052a 930f
00052b e000
00052c bf0f                      	PushSREG
                                 	;in r16, SREG
                                 	;push r16
00052d 931f                      	push r17
00052e 932f                      	push r18
00052f 93af                      	push	XL
000530 93bf                      	push	XH
000531 93ef                      	push	ZL
000532 93ff                      	push	ZH
                                 
                                 	;cli
                                 
000533 e807                      	ldi temp, 0b10000111
000534 b906                      	out ADCSRA, temp
                                 	;ldi XL,low(AI_data)
                                 	;ldi XH,high(AI_data)
                                 	;lds r16, temperature
                                 	;st X+, r16
                                 	;lds r16, temperature+1
                                 	;st X+, r16
000535 9120 014d                 	lds		r18,	system_reg
                                 
000537 91b0 01d5                 	lds		XH,		temperature
000539 91a0 01d6                 	lds		XL,		temperature+1
                                 
00053b e0f0                      	ldi		ZH,		high(2*TemprAr_Values)
00053c e1ee                      	ldi		ZL,		low(2*TemprAr_Values)
                                 
00053d ef2f                      	ldi		r18,	-1
                                 	Temperature_Read_Convertion:
00053e 9523                      		inc		r18
00053f 3728                      		cpi		r18,	TemprAr_Size
000540 f029                      		breq	Temperature_Read_Convertion_End
000541 9105                      		lpm		r16,	Z+
000542 9115                      		lpm		r17,	Z+
000543 1b0a                      		sub		r16,	XL
000544 071b                      		cpc		r17,	XH
000545 f7c0                      		brsh	Temperature_Read_Convertion
                                 	Temperature_Read_Convertion_End:
000546 2700                      	clr		r16
000547 9300 01d3                 	sts		TemprAr_index,	r16
000549 9320 01d4                 	sts		TemprAr_index+1,	r18
00054b 9110 0217                 	lds		r17,	temperature_min
00054d 9100 0218                 	lds		r16,	temperature_min+1
                                 
00054f 1b0a                      	sub		r16,	XL
000550 071b                      	cpc		r17,	XH
000551 f420                      	brsh	check_over_max
                                 		;sbrc	r18,	0
000552 e006                      		ldi temp, 6 ;Включаем таймер
000553 bd05                      		out TCCR2, temp
000554 e021                      		ldi		r18,	0x01
000555 c00e                      		rjmp	Read_end
                                 
                                 	check_over_max:
000556 9110 0215                 	lds		r17,	temperature_max
000558 9100 0216                 	lds		r16,	temperature_max+1
                                 	;adiw	r16,	1
00055a 1b0a                      	sub		r16,	XL
00055b 071b                      	cpc		r17,	XH
00055c f020                      	brlo	good_temp
                                 		;sbrc	r18,	1
00055d e026                      		ldi		r18,	6 ;Включаем таймер
00055e bd25                      		out		TCCR2,	r18
00055f e022                      		ldi		r18,	0x02
000560 c003                      		rjmp	Read_end
                                 
                                 	good_temp:
000561 e026                      		ldi		r18,	6 ;Включаем таймер
000562 bd25                      		out		TCCR2,	r18
000563 e020                      		ldi		r18,	0x00
                                 	Read_end:
000564 9320 014d                 	sts		system_reg,	r18
000566 ec0f                      	ldi		temp,		0b11001111
000567 b906                      	out		ADCSRA,		temp
000568 91ff                      	pop		ZH
000569 91ef                      	pop		ZL
00056a 91bf                      	pop		XH
00056b 91af                      	pop		XL
00056c 912f                      	pop		r18
00056d 911f                      	pop		r17
00056e 910f
00056f bf0f                      	popSREG
000570 910f                      	pop		r16
000571 9508                      ret
                                 	/*
                                 	lds r17, temperature_min
                                 	cp r16,r17
                                 	brsh temp_over_min
                                 
                                 	lds r17, temperature_max
                                 	cp r16,r17
                                 	brlo temp_over_max
                                 		andi r18, 0b11111100
                                 		ldi temp, 5 ;Включаем таймер
                                 		out TCCR2, temp
                                 		;cbi r18,0
                                 		;cbi r18,1
                                 	rjmp temp_read_end
                                 	temp_over_min:
                                 		ori r18, 0b00000001
                                 		;andi r18, 0b11111101
                                 		;sbi r18,0
                                 		ldi temp, 5 ;Включаем таймер
                                 		out TCCR2, temp
                                 		rjmp temp_read_end
                                 	temp_over_max:
                                 		ori r18, 0b00000010
                                 		;andi r18, 0b11111110
                                 		;sbi r18,1
                                 		ldi temp, 5 ;Включаем таймер
                                 		out TCCR2,	 temp
                                 		rjmp temp_read_end
                                 	temp_read_end:
                                 	st X,r18
                                 	sei
                                 
                                 	ldi temp, 0b11001111
                                 	out ADCSRA, temp
                                 
                                 	pop r18
                                 	pop r17
                                 	PopSREG
                                 	;pop r16
                                 	;out SREG, r16
                                 	pop r16
                                 ret
                                 */
                                 
                                 
                                 ;-------------Прерывание по приёму байта-----------------;
                                 USART_RXC:
                                 	;push r16
                                 	;in r16, SREG
000572 930f                      	push r16
000573 b70f
000574 930f
000575 e000
000576 bf0f                      	pushSreg
000577 933f                      	push r19
000578 934f                      	push r20
                                 
000579 9140 0120                 	lds r20,in_offset
00057b 314f                      	cpi r20, BUF_LEN-1
00057c f460                      	brsh RXC_end					; защита на слишком длинный пакет
                                 
00057d b10b                      	in r16, UCSRA
00057e ff07                      	sbrs r16, RXC
00057f cff2                      	rjmp USART_RXC
                                 
                                 	in_setbyte:
000580 b10c                      	in r16, UDR					 ;Запись в буфер приёма
000581 9301                      	st Z+,r16
000582 9543                      	inc r20 
000583 9340 0120                 	sts in_offset, r20
000585 e044                      	ldi r20,READ_TIME 
000586 9340 0121                 	sts in_flag, r20
000588 c000                      	rjmp RXC_end
                                 
                                 	RXC_end:
000589 914f                      	pop r20
00058a 913f                      	pop r19
00058b 910f
00058c bf0f                      	popSreg
00058d 910f                      	pop r16
                                 	;out SREG, r16
                                 	;pop r16
00058e 9518                      reti
                                 
                                 /*TIMER2_OVF:							; Прерывание по переполнению 2 таймера
                                 	push r20
                                 	in r20, SREG
                                 	push r20
                                 	push r21
                                 	;
                                 	lds r20, out_flag				; Загружаем доп. байт для адекватного времени моргания
                                 	and r20,r20
                                 	breq OVF2_Flag_Null
                                 	dec r20
                                 	sts out_flag, r20
                                 	rjmp OVF2_end
                                   OVF2_Flag_Null:
                                 	;ldi XH,high(DO_data)			
                                 	;ldi XL,low(DO_data)
                                 	;ld r21, X+
                                 	;cbr r21, $10					; Заносим изменение по биту, которое в main передаётся на пин к светодиоду
                                 	;st -X, r21
                                 	ldi r20, 0						; Выключаем счётчик тактов у таймера -> выключаем таймер до необходимого момента
                                 	out TCCR2, r20
                                 	ldi r20, 5						; Заносим небходимое кол-во доп. циклов в доп. байт
                                 	sts out_flag, r20
                                   OVF2_end:
                                 	pop r21
                                 	pop r20
                                 	out SREG, r20
                                 	pop r20
                                 reti*/
                                 
                                 TIMER2_OVF:							; Таймер на проверку перехода температуры
                                 	;cli
                                 	;push r16
                                 	;in r16, SREG
00058f 930f                      	push	r16
000590 b70f
000591 930f
000592 e000
000593 bf0f                      	PushSREG
                                 	;ldi r16, 0b11000100
                                 	;out ADCSRA, temp
                                 
000594 931f                      	push	r17
000595 932f                      	push	r18
000596 93af                      	push	XL
000597 93bf                      	push	XH
                                 	;ldi temp, 0				;Вычключаем таймер
                                 	;out TCCR1B, temp
                                 	;/*
000598 e000                      	ldi r16, 0
000599 bd05                      	out TCCR2, r16
                                 	;ldi XL,low(DI_data)
                                 	;ldi XH,high(DI_data)
00059a 9120 014d                 	lds		r18,	system_reg
                                 
00059c 91b0 01d5                 	lds		XH,		temperature
00059e 91a0 01d6                 	lds		XL,		temperature+1
                                 
0005a0 9110 0217                 	lds		r17,	temperature_min
0005a2 9100 0218                 	lds		r16,	temperature_min+1
                                 
0005a4 1b0a                      	sub		r16,	XL
0005a5 071b                      	cpc		r17,	XH
0005a6 f418                      	brsh	TIMER2_OVF_check_over_max
0005a7 fd20                      		sbrc	r18,	0
0005a8 e021                      			ldi		r18,	0x01
0005a9 c00b                      		rjmp	TIMER2_OVF_END
                                 
                                 	TIMER2_OVF_check_over_max:
0005aa 9110 0215                 	lds		r17,	temperature_max
0005ac 9100 0216                 	lds		r16,	temperature_max+1
                                 	;adiw	r16,	1
0005ae 1b0a                      	sub		r16,	XL
0005af 071b                      	cpc		r17,	XH
0005b0 f018                      	brlo	TIMER2_OVF_good_temp
0005b1 fd21                      		sbrc	r18,	1
0005b2 e022                      			ldi		r18,	0x02
0005b3 c001                      		rjmp	TIMER2_OVF_END
                                 
                                 	TIMER2_OVF_good_temp:
0005b4 e020                      		ldi		r18,	0x00
                                 
                                 	TIMER2_OVF_END:
0005b5 9320 0193                 	sts		DI_Data,	r18
0005b7 9320 014d                 	sts		system_reg,	r18
0005b9 91bf                      	pop		XH
0005ba 91af                      	pop		XL
0005bb 912f                      	pop		r18
0005bc 911f                      	pop		r17
0005bd 910f
0005be bf0f                      	PopSREG
0005bf 910f                      	pop		r16
0005c0 9518                      reti
                                 /*
                                 
                                 		brlo over_max_confirm
                                 
                                 	lds r17, temperature_min
                                 	cp r16, r17
                                 		brsh over_min_confirm
                                 
                                 	rjmp TIMER2_OVF_END
                                 	over_max_confirm:
                                 		ld r17, X+
                                 		sbrc r17,1
                                 		ldi r18,0x02
                                 		rjmp TIMER2_OVF_END
                                 
                                 	over_min_confirm:
                                 		ld r17, X+
                                 		sbrc r17,0
                                 		ldi r18,0x01
                                 		rjmp TIMER2_OVF_END
                                 	TIMER2_OVF_END:
                                 	
                                 	;ldi r16, 0
                                 	;out TCCR2, r16
                                 	; Запись в пямять для индикации
                                 	ldi XL,low(DI_data)
                                 	ldi XH,high(DI_data)
                                 	ld r16, X+
                                 	;andi r18,0b00000011
                                 	;lsl r18
                                 	lsl r18
                                 	lsl r18
                                 	lsl r18
                                 	andi r16, 0b11100111
                                 	or r16, r18
                                 	st -X,r16
                                 
                                 	pop	ZH
                                 	pop	ZL
                                 	pop	XH
                                 	pop	XL
                                 	pop r18
                                 	pop r17
                                 	;ldi r16, 0b11001001
                                 	;out ADCSRA, temp
                                 	pop r16
                                 	;out SREG, r16
                                 	;pop r16
                                 	;sei
                                 reti
                                 */
                                 
                                 TIMER0_OVF:							; Прерывание по переполнению 0 таймера - проверка на конец пакета
                                 	;push r20
                                 	;in r20, SREG
0005c1 934f                      	push r20
0005c2 9140 0121                 	lds r20, in_flag				; Цикл 4 раза проходит по времени принятия одного байта, и если новых байт на приёме нет,
0005c4 2344                      	and r20,r20						; то в in_flag заносится 0,что сигнализирует о окончании пакета
0005c5 f019                      	breq OVF0_end
0005c6 954a                      	dec r20
0005c7 9340 0121                 	sts in_flag,r20
                                   OVF0_end:
0005c9 914f                      	pop r20
                                 	;out SREG, r20
                                 	;pop r20


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega8A" register use summary:
x  :  31 y  :  44 z  :  44 r0 :   0 r1 :   0 r2 :   0 r3 :   0 r4 :   0 
r5 :   0 r6 :   0 r7 :   0 r8 :   0 r9 :   0 r10:   0 r11:   0 r12:   0 
r13:   0 r14:   0 r15:   0 r16: 349 r17: 138 r18:  56 r19:  98 r20:  52 
r21:  39 r22:  37 r23:   3 r24:  48 r25:   0 r26:  80 r27:  63 r28:   4 
r29:   4 r30:   9 r31:   9 
Registers used: 18 out of 35 (51.4%)

"ATmega8A" instruction use summary:
.lds  :   0 .sts  :   0 adc   :   0 add   :  12 adiw  :   0 and   :   7 
andi  :   0 asr   :   0 bclr  :   0 bld   :   0 brbc  :   0 brbs  :   0 
brcc  :   2 brcs  :   0 breq  :  31 brge  :   0 brhc  :   0 brhs  :   0 
brid  :   0 brie  :   0 brlo  :  21 brlt  :   0 brmi  :   0 brne  :  64 
brpl  :   0 brsh  :  20 brtc  :   0 brts  :   0 brvc  :   0 brvs  :   0 
bset  :   0 bst   :   0 cbi   :   6 cbr   :   0 clc   :   0 clh   :   0 
cli   :   2 cln   :   0 clr   :   1 cls   :   0 clt   :   0 clv   :   0 
clz   :   0 com   :   1 cp    :  12 cpc   :   5 cpi   :  75 cpse  :   2 
dec   :  32 eor   :   6 fmul  :   0 fmuls :   0 fmulsu:   0 icall :   0 
ijmp  :   0 in    :  22 inc   :  41 ld    :  64 ldd   :   0 ldi   : 166 
lds   :  65 lpm   :   2 lsl   :   5 lsr   :   6 mov   :  27 movw  :   0 
mul   :   1 muls  :   0 mulsu :   0 neg   :   0 nop   :  29 or    :   1 
ori   :   0 out   :  72 pop   :  58 push  :  58 rcall :  11 ret   :   4 
reti  :   4 rjmp  :  86 rol   :   4 ror   :   6 sbc   :   0 sbci  :   0 
sbi   :  16 sbic  :   9 sbis  :   0 sbiw  :   4 sbr   :   0 sbrc  :   2 
sbrs  :   4 sec   :   2 seh   :   0 sei   :   3 sen   :   0 ser   :   0 
ses   :   0 set   :   0 sev   :   0 sez   :   0 sleep :   0 spm   :   0 
st    :  53 std   :   0 sts   :  74 sub   :   9 subi  :   6 swap  :   0 
tst   :   0 wdr   :   0 
Instructions used: 49 out of 110 (44.5%)

"ATmega8A" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x000b96   2704    242   2946    8192  36.0%
[.dseg] 0x000060 0x000253      0    339    339    1024  33.1%
[.eseg] 0x000000 0x000000      0      0      0     512   0.0%

Assembly complete, 0 errors, 5 warnings
